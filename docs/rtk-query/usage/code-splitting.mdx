---
id: code-splitting
title: 코드 분할
sidebar_label: 코드 분할
hide_title: true
description: 'RTK Query > 사용법 > 코드 분할: dynamic injection of endpoints'
---

&nbsp;

# 코드 분할

RTK Query를 사용하면 초기 서비스 정의를 설정한 후 추가 엔드포인트를 삽입할 수 있으므로 초기 번들 크기를 줄일 수 있습니다. 이는 _많은_ 엔드포인트를 가질 수 있는 큰 애플리케이션에 매우 유용할 수 있습니다.

`injectEndpoints`는 엔드포인트 컬렉션과, 선택적 `overrideExisting` 매개변수를 허용합니다.

`injectEndpoints`를 호출하면 엔드포인트들을 원래의 API에 주입하고, 이러한 엔드포인트들에 대해 올바른 타입을 가진 동일한 API도 제공합니다. (안타깝게도 원본 정의의 타입은 변경할 수 없습니다.)

일반적인 접근 방식은 하나의 빈 중앙 API slice 정의를 만드는 것입니다:

```ts title="Basic setup"
// Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// initialize an empty api service that we'll inject endpoints into later as needed
export const emptySplitApi = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/' }),
  endpoints: () => ({}),
})
```

그 뒤, 다른 파일에서 api 엔드포인트들을 주입하고 거기에서 export 하세요 - that way you will be sure to always import the endpoints in a way that they are definitely injected.

```ts title="Injecting & exporting additional endpoints"
// file: emptySplitApi.ts noEmit
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const emptySplitApi = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/' }),
  endpoints: () => ({}),
})

// file: extendedApi.ts
import { emptySplitApi } from './emptySplitApi'

const extendedApi = emptySplitApi.injectEndpoints({
  endpoints: (build) => ({
    example: build.query({
      query: () => 'test',
    }),
  }),
  overrideExisting: false,
})

export const { useExampleQuery } = extendedApi
```

:::tip
개발 환경에서 'overrideExisting: true'를 명시적으로 지정하지 않고 이미 존재하는 엔드포인트를 삽입하면 경고가 표시됩니다. **프로덕션 환경에서는 이것을 볼 수 없으며** 또한 기존 엔드포인트가 덮어씌워지므로, 테스트시엔 이를 고려해야 합니다.
:::
