---
id: mutations
title: Mutations
sidebar_label: Mutations
hide_title: true
description: 'RTK Query > 사용법 > Mutations: sending updates to the server'
---

&nbsp;

# Mutations

## Overview

Mutations은 데이터 업데이트를 서버로 전송하고 변경 사항을 로컬 캐시에 적용하는 데 사용됩니다. Mutations은 캐시된 데이터를 무효화하고 강제로 다시 가져올 수도(force re-fetch) 있습니다.

## Mutation Endpoint 정의하기

Mutation endpoint는 `createApi`의 `endpoints` 섹션에서 `build.mutation()` 메소드를 통해 정의합니다.

Mutation endpoints는 URL을 구성하는 `query` 콜백 함수 (including any URL query params), 또는 임의의 비동기 로직을 처리하고 결과를 반환해야 한다면 [`queryFn` 콜백 함수](./customizing-queries.mdx#customizing-queries-with-queryfn) 를 정의하고 있어야 합니다. The `query` callback may also return an object containing the URL, the HTTP method to use and a request body.

If the `query` callback needs additional data to generate the URL, it should be written to take a single argument. 여러 매개변수를 전달해야 하는 경우 단일 "옵션 객체" 형식으로 전달하세요.

Mutation endpoint는 요청에 따른 결과가 캐시되기 전에 응답 내용을 수정할 수 있고, 캐시 무효화를 식별하기 위해 태그를 정의할 수 있으며, 캐시 항목이 추가 및 제거될 때마다 추가 로직을 실행하기 위해서 캐시 라이프사이클 콜백 함수를 제공할 수 있습니다.

```ts title="Example of all mutation endpoint options"
// file: types.ts noEmit
export interface Post {
  id: number
  name: string
}

// file: api.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
import type { Post } from './types'

const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: '/',
  }),
  tagTypes: ['Post'],
  endpoints: (build) => ({
    updatePost: build.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({
      // highlight-start
      // note: an optional `queryFn` may be used in place of `query`
      query: ({ id, ...patch }) => ({
        url: `post/${id}`,
        method: 'PATCH',
        body: patch,
      }),
      // Pick out data and prevent nested properties in a hook or selector
      transformResponse: (response: { data: Post }, meta, arg) => response.data,
      invalidatesTags: ['Post'],
      // onQueryStarted is useful for optimistic updates
      // The 2nd parameter is the destructured `MutationLifecycleApi`
      async onQueryStarted(
        arg,
        { dispatch, getState, queryFulfilled, requestId, extra, getCacheEntry }
      ) {},
      // The 2nd parameter is the destructured `MutationCacheLifecycleApi`
      async onCacheEntryAdded(
        arg,
        {
          dispatch,
          getState,
          extra,
          requestId,
          cacheEntryRemoved,
          cacheDataLoaded,
          getCacheEntry,
        }
      ) {},
      // highlight-end
    }),
  }),
})
```

:::info

`onQueryStarted` 메소드는 [optimistic updates](./manual-cache-updates.mdx#optimistic-updates) 에 사용될 수 있습니다.

:::

## Performing Mutations with React Hooks

### Mutation Hook Behavior

`useQuery`와 달리 `useMutation`은 tuple을 반환합니다. tuple의 첫번째 항목은 "trigger" 함수이며, 두번째 항목은 `status`, `error`, 및 `data` 가 들어있는 object입니다.

`useQuery`와 달리 `useMutation`은 자동적으로 실행되지 않습니다. Mutation을 실행하기 위해서는 hook에서 반환된 튜플의 첫번째 항목인 trigger 함수를 호출해야 합니다.

See [`useMutation`](../api/created-api/hooks.mdx#usemutation) for the hook signature and additional details.

### Frequently Used Mutation Hook Return Values

앞서 말한 대로 `useMutation` hook은 "mutation trigger" 함수와 뮤테이션 결과를 담고 있는 객체인 "mutation result"를 튜플의 형태로 반환합니다.

The "mutation trigger" is a function that when called, will fire off the mutation request for that endpoint. Calling the "mutation trigger" returns a promise with an `unwrap` property, which can be called to unwrap the mutation call and provide the raw response/error. This can be useful if you wish to determine whether the mutation succeeds/fails inline at the call-site.

The "mutation result" is an object containing properties such as the latest `data` for the mutation request, as well as status booleans for the current request lifecycle state.

다음은 "mutation result" 객체에서 가장 자주 사용되는 속성 중 일부입니다. Refer to [`useMutation`](../api/created-api/hooks.mdx#usemutation) for an extensive list of all returned properties.

- `data` - The data returned from the latest trigger response, if present. If subsequent triggers from the same hook instance are called, this will return undefined until the new data is received. 새 데이터로의 smooth transition을 원한다면 component level의 caching을 고려하세요.
- `error` - 오류 결과가 존재한다면 이를 반환합니다.
- `isUninitialized` - True라면, mutation이 한번도 실행되지 않았음을 나타냅니다.
- `isLoading` - True라면, mutation이 실행되어 응답을 기다리고 있음을 나타냅니다.
- `isSuccess` - True라면, 마지막으로 실행된 mutation의 응답에 성공적으로 data가 있음을 나타냅니다.
- `isError` - True라면, 마지막으로 실행된 mutation의 응답에 오류가 있음을 나타냅니다.
- `reset` - hook을 초기 상태로 되돌리며 캐시에서 현재 결과를 제거하는 메소드입니다.

:::note

With RTK Query, a mutation does not contain a semantic distinction between 'loading' and 'fetching' in the way that a [query does](./queries.mdx#frequently-used-query-hook-return-values). For a mutation, subsequent calls are not assumed to be necessarily related, so a mutation is either 'loading' or 'not loading', with no concept of 're-fetching'.

:::

### Shared Mutation Results

By default, separate instances of a `useMutation` hook are not inherently related to each other.
Triggering one instance will not affect the result for a separate instance. This applies regardless
of whether the hooks are called within the same component, or different components.

```tsx no-transpile
export const ComponentOne = () => {
  // Triggering `updatePostOne` will affect the result in this component,
  // but not the result in `ComponentTwo`, and vice-versa
  const [updatePost, result] = useUpdatePostMutation()

  return <div>...</div>
}

export const ComponentTwo = () => {
  const [updatePost, result] = useUpdatePostMutation()

  return <div>...</div>
}
```

RTK Query는 'fixedCacheKey' 옵션을 통해 mutation hook instances 간에 결과를 공유하는 옵션을 제공합니다.
Any `useMutation` hooks with the same `fixedCacheKey` string will share results between each other
when any of the trigger functions are called. This should be a unique string shared between each
mutation hook instance you wish to share results.

```tsx no-transpile
export const ComponentOne = () => {
  // Triggering `updatePostOne` will affect the result in both this component,
  // but as well as the result in `ComponentTwo`, and vice-versa
  const [updatePost, result] = useUpdatePostMutation({
    fixedCacheKey: 'shared-update-post',
  })

  return <div>...</div>
}

export const ComponentTwo = () => {
  const [updatePost, result] = useUpdatePostMutation({
    fixedCacheKey: 'shared-update-post',
  })

  return <div>...</div>
}
```

:::note

`fixedCacheKey`를 사용할 경우, `originalArgs` 속성은 공유될 수 없으며 항상 `undefined` 값이 됩니다.

:::

### Standard Mutation Example

This is a modified version of the complete example you can see at the bottom of the page to highlight the `updatePost` mutation. In this scenario, a post is fetched with `useQuery`, and then an `EditablePostName` component is rendered that allows us to edit the name of the post.

```tsx title="src/features/posts/PostDetail.tsx"
export const PostDetail = () => {
  const { id } = useParams<{ id: any }>()

  const { data: post } = useGetPostQuery(id)

  // highlight-start
  const [
    updatePost, // This is the mutation trigger
    { isLoading: isUpdating }, // This is the destructured mutation result
  ] = useUpdatePostMutation()
  // highlight-end

  return (
    <Box p={4}>
      <EditablePostName
        name={post.name}
        onUpdate={(name) => {
          // If you want to immediately access the result of a mutation, you need to chain `.unwrap()`
          // if you actually want the payload or to catch the error.
          // Example: `updatePost().unwrap().then(fulfilled => console.log(fulfilled)).catch(rejected => console.error(rejected))

          return (
            // highlight-start
            // Execute the trigger with the `id` and updated `name`
            updatePost({ id, name })
            // highlight-end
          )
        }}
        // highlight-start
        isLoading={isUpdating}
        // highlight-end
      />
    </Box>
  )
}
```

## Advanced Mutations with Revalidation

현실 세계에서는 개발자가 mutation을 실행한 후, 로컬 데이터 캐시를 서버와 동기화 하는 것이 매우 일반적입니다 (aka "revalidation"). RTK 쿼리는 이에 대한 보다 중앙 집중식 접근 방식을 취하며 API 서비스 정의에서 invalidation behavior을 구성해야 합니다. See [Advanced Invalidation with abstract tag IDs](./automated-refetching#advanced-invalidation-with-abstract-tag-ids) for details on advanced invalidation handling with RTK Query.

### Revalidation Example

This is an example of a [CRUD service](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) for Posts. This implements the [Selectively invalidating lists](./automated-refetching#selectively-invalidating-lists) strategy and will most likely serve as a good foundation for real applications.

```ts title="src/app/services/posts.ts"
// Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export interface Post {
  id: number
  name: string
}

type PostsResponse = Post[]

export const postApi = createApi({
  reducerPath: 'postsApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/' }),
  tagTypes: ['Posts'],
  endpoints: (build) => ({
    getPosts: build.query<PostsResponse, void>({
      query: () => 'posts',
      // Provides a list of `Posts` by `id`.
      // If any mutation is executed that `invalidate`s any of these tags, this query will re-run to be always up-to-date.
      // The `LIST` id is a "virtual id" we just made up to be able to invalidate this query specifically if a new `Posts` element was added.
      providesTags: (result) =>
        // is result available?
        result
          ? // successful query
            [
              ...result.map(({ id }) => ({ type: 'Posts', id } as const)),
              { type: 'Posts', id: 'LIST' },
            ]
          : // an error occurred, but we still want to refetch this query when `{ type: 'Posts', id: 'LIST' }` is invalidated
            [{ type: 'Posts', id: 'LIST' }],
    }),
    addPost: build.mutation<Post, Partial<Post>>({
      query(body) {
        return {
          url: `post`,
          method: 'POST',
          body,
        }
      },
      // Invalidates all Post-type queries providing the `LIST` id - after all, depending of the sort order,
      // that newly created post could show up in any lists.
      invalidatesTags: [{ type: 'Posts', id: 'LIST' }],
    }),
    getPost: build.query<Post, number>({
      query: (id) => `post/${id}`,
      providesTags: (result, error, id) => [{ type: 'Posts', id }],
    }),
    updatePost: build.mutation<Post, Partial<Post>>({
      query(data) {
        const { id, ...body } = data
        return {
          url: `post/${id}`,
          method: 'PUT',
          body,
        }
      },
      // Invalidates all queries that subscribe to this Post `id` only.
      // In this case, `getPost` will be re-run. `getPosts` *might*  rerun, if this id was under its results.
      invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }],
    }),
    deletePost: build.mutation<{ success: boolean; id: number }, number>({
      query(id) {
        return {
          url: `post/${id}`,
          method: 'DELETE',
        }
      },
      // Invalidates all queries that subscribe to this Post `id` only.
      invalidatesTags: (result, error, id) => [{ type: 'Posts', id }],
    }),
  }),
})

export const {
  useGetPostsQuery,
  useAddPostMutation,
  useGetPostQuery,
  useUpdatePostMutation,
  useDeletePostMutation,
} = postApi
```

<iframe
  src="https://codesandbox.io/embed/github/reduxjs/redux-toolkit/tree/master/examples/query/react/mutations?fontsize=14&runonclick=1&hidenavigation=1&module=%2Fsrc%2Fapp%2Fservices%2Fposts.ts&theme=dark"
  style={{
    width: '100%',
    height: '600px',
    border: 0,
    borderRadius: '4px',
    overflow: 'hidden',
  }}
  title="RTK Query - Mutations Example"
  allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
></iframe>
