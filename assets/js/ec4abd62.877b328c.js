"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6776],{6615:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return c}});var a=n(5773),i=n(808),r=(n(7378),n(5318)),s=(n(517),n(7637),["components"]),o={id:"createListenerMiddleware",title:"createListenerMiddleware",sidebar_label:"createListenerMiddleware",hide_title:!0},l=void 0,d={unversionedId:"api/createListenerMiddleware",id:"api/createListenerMiddleware",isDocsHomePage:!1,title:"createListenerMiddleware",description:"&nbsp;",source:"@site/../docs/api/createListenerMiddleware.mdx",sourceDirName:"api",slug:"/api/createListenerMiddleware",permalink:"/redux-toolkit/api/createListenerMiddleware",tags:[],version:"current",lastUpdatedAt:1656242924,formattedLastUpdatedAt:"6/26/2022",frontMatter:{id:"createListenerMiddleware",title:"createListenerMiddleware",sidebar_label:"createListenerMiddleware",hide_title:!0},sidebar:"docs",previous:{title:"Serializability Middleware",permalink:"/redux-toolkit/api/serializabilityMiddleware"},next:{title:"createReducer",permalink:"/redux-toolkit/api/createReducer"}},c=[{value:"Overview",id:"overview",children:[{value:"Basic Usage",id:"basic-usage",children:[],level:3}],level:2},{value:"<code>createListenerMiddleware</code>",id:"createlistenermiddleware-1",children:[{value:"Middleware Options",id:"middleware-options",children:[],level:3}],level:2},{value:"Listener Middleware Instance",id:"listener-middleware-instance",children:[{value:"<code>middleware</code>",id:"middleware",children:[],level:3},{value:"<code>startListening</code>",id:"startlistening",children:[],level:3},{value:"<code>stopListening</code>",id:"stoplistening",children:[],level:3},{value:"<code>clearListeners</code>",id:"clearlisteners",children:[],level:3}],level:2},{value:"Action Creators",id:"action-creators",children:[{value:"<code>addListener</code>",id:"addlistener",children:[],level:3},{value:"<code>removeListener</code>",id:"removelistener",children:[],level:3},{value:"<code>clearAllListeners</code>",id:"clearalllisteners",children:[],level:3}],level:2},{value:"Listener API",id:"listener-api",children:[{value:"Store Interaction Methods",id:"store-interaction-methods",children:[],level:3},{value:"Listener Subscription Management",id:"listener-subscription-management",children:[],level:3},{value:"Conditional Workflow Execution",id:"conditional-workflow-execution",children:[],level:3},{value:"Child Tasks",id:"child-tasks",children:[],level:3}],level:2},{value:"TypeScript Usage",id:"typescript-usage",children:[],level:2},{value:"Usage Guide",id:"usage-guide",children:[{value:"Overall Purpose",id:"overall-purpose",children:[],level:3},{value:"Standard Usage Patterns",id:"standard-usage-patterns",children:[],level:3},{value:"Writing Async Workflows with Conditions",id:"writing-async-workflows-with-conditions",children:[],level:3},{value:"Cancellation and Task Management",id:"cancellation-and-task-management",children:[],level:3},{value:"Complex Async Workflows",id:"complex-async-workflows",children:[],level:3},{value:"Adding Listeners Inside Components",id:"adding-listeners-inside-components",children:[],level:3},{value:"Organizing Listeners in Files",id:"organizing-listeners-in-files",children:[],level:3}],level:2}],p={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"createlistenermiddleware"},(0,r.kt)("inlineCode",{parentName:"h1"},"createListenerMiddleware")),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,'A Redux middleware that lets you define "listener" entries that contain an "effect" callback with additional logic, and a way to specify when that callback should run based on dispatched actions or state changes.'),(0,r.kt)("p",null,"It's intended to be a lightweight alternative to more widely used Redux async middleware like sagas and observables. While similar to thunks in level of complexity and concept, it can be used to replicate some common saga usage patterns."),(0,r.kt)("p",null,"Conceptually, you can think of this as being similar to React's ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect")," hook, except that it runs logic in response to Redux store updates instead of component props/state updates."),(0,r.kt)("p",null,"Listener effect callbacks have access to ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getState"),", similar to thunks. The listener also receives a set of async workflow functions like ",(0,r.kt)("inlineCode",{parentName:"p"},"take"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"condition"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"pause"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"fork"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"unsubscribe"),", which allow writing more complex async logic."),(0,r.kt)("p",null,"Listeners can be defined statically by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerMiddleware.startListening()")," during setup, or added and removed dynamically at runtime with special ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(addListener())")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(removeListener())")," actions."),(0,r.kt)("h3",{id:"basic-usage"},"Basic Usage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { configureStore, createListenerMiddleware } from '@reduxjs/toolkit'\n\nimport todosReducer, {\n  todoAdded,\n  todoToggled,\n  todoDeleted,\n} from '../features/todos/todosSlice'\n\n// Create the middleware instance and methods\nconst listenerMiddleware = createListenerMiddleware()\n\n// Add one or more listener entries that look for specific actions.\n// They may contain any sync or async logic, similar to thunks.\nlistenerMiddleware.startListening({\n  actionCreator: todoAdded,\n  effect: async (action, listenerApi) => {\n    // Run whatever additional side-effect-y logic you want here\n    console.log('Todo added: ', action.payload.text)\n\n    // Can cancel other running instances\n    listenerApi.cancelActiveListeners()\n\n    // Run async logic\n    const data = await fetchData()\n\n    // Pause until action dispatched or state changed\n    if (await listenerApi.condition(matchSomeAction)) {\n      // Use the listener API methods to dispatch, get state,\n      // unsubscribe the listener, start child tasks, and more\n      listenerApi.dispatch(todoAdded('Buy pet food'))\n\n      // Spawn \"child tasks\" that can do more work and return results\n      const task = listenerApi.fork(async (forkApi) => {\n        // Can pause execution\n        await forkApi.delay(5)\n        // Complete the child by returning a value\n        return 42\n      })\n\n      const result = await task.result\n      // Unwrap the child result in the listener\n      if (result.status === 'ok') {\n        // Logs the `42` result value that was returned\n        console.log('Child succeeded: ', result.value)\n      }\n    }\n  },\n})\n\nconst store = configureStore({\n  reducer: {\n    todos: todosReducer,\n  },\n  // Add the listener middleware to the store.\n  // NOTE: Since this can receive actions with functions inside,\n  // it should go before the serializability check middleware\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().prepend(listenerMiddleware.middleware),\n})\n")),(0,r.kt)("h2",{id:"createlistenermiddleware-1"},(0,r.kt)("inlineCode",{parentName:"h2"},"createListenerMiddleware")),(0,r.kt)("p",null,"Creates an instance of the middleware, which should then be added to the store via ",(0,r.kt)("inlineCode",{parentName:"p"},"configureStore"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"middleware")," parameter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const createListenerMiddleware = (options?: CreateMiddlewareOptions) =>\n  ListenerMiddlewareInstance\n\ninterface CreateListenerMiddlewareOptions<ExtraArgument = unknown> {\n  extra?: ExtraArgument\n  onError?: ListenerErrorHandler\n}\n\ntype ListenerErrorHandler = (\n  error: unknown,\n  errorInfo: ListenerErrorInfo\n) => void\n\ninterface ListenerErrorInfo {\n  raisedBy: 'effect' | 'predicate'\n}\n")),(0,r.kt)("h3",{id:"middleware-options"},"Middleware Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extra"),': an optional "extra argument" that will be injected into the ',(0,r.kt)("inlineCode",{parentName:"li"},"listenerApi")," parameter of each listener. Equivalent to ",(0,r.kt)("a",{parentName:"li",href:"https://redux.js.org/usage/writing-logic-thunks#injecting-config-values-into-thunks"},'the "extra argument" in the Redux Thunk middleware')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"onError"),": an optional error handler that gets called with synchronous and async errors raised by ",(0,r.kt)("inlineCode",{parentName:"li"},"listener")," and synchronous errors thrown by ",(0,r.kt)("inlineCode",{parentName:"li"},"predicate"),".")),(0,r.kt)("h2",{id:"listener-middleware-instance"},"Listener Middleware Instance"),(0,r.kt)("p",null,'The "listener middleware instance" returned from ',(0,r.kt)("inlineCode",{parentName:"p"},"createListenerMiddleware"),' is an object similar to the "slice" objects generated by ',(0,r.kt)("inlineCode",{parentName:"p"},"createSlice"),". The instance object is ",(0,r.kt)("em",{parentName:"p"},"not")," the actual Redux middleware itself. Rather, it contains the middleware and some instance methods used to add and remove listener entries within the middleware."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"interface ListenerMiddlewareInstance<\n  State = unknown,\n  Dispatch extends ThunkDispatch<State, unknown, AnyAction> = ThunkDispatch<\n    State,\n    unknown,\n    AnyAction\n  >,\n  ExtraArgument = unknown\n> {\n  middleware: ListenerMiddleware<State, Dispatch, ExtraArgument>\n  startListening: (options: AddListenerOptions) => Unsubscribe\n  stopListening: (\n    options: AddListenerOptions & UnsubscribeListenerOptions\n  ) => boolean\n  clearListeners: () => void\n}\n")),(0,r.kt)("h3",{id:"middleware"},(0,r.kt)("inlineCode",{parentName:"h3"},"middleware")),(0,r.kt)("p",null,"The actual Redux middleware. Add this to the Redux store via ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/api/configureStore#middleware"},"the ",(0,r.kt)("inlineCode",{parentName:"a"},"configureStore.middleware")," option"),"."),(0,r.kt)("p",null,'Since the listener middleware can receive "add" and "remove" actions containing functions, this should normally be added as the first middleware in the chain so that it is before the serializability check middleware.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const store = configureStore({\n  reducer: {\n    todos: todosReducer,\n  },\n  // Add the listener middleware to the store.\n  // NOTE: Since this can receive actions with functions inside,\n  // it should go before the serializability check middleware\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().prepend(listenerMiddleware.middleware),\n})\n")),(0,r.kt)("h3",{id:"startlistening"},(0,r.kt)("inlineCode",{parentName:"h3"},"startListening")),(0,r.kt)("p",null,'Adds a new listener entry to the middleware. Typically used to "statically" add new listeners during application setup.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const startListening = (options: AddListenerOptions) => UnsubscribeListener\n\ninterface AddListenerOptions {\n  // Four options for deciding when the listener will run:\n\n  // 1) Exact action type string match\n  type?: string\n\n  // 2) Exact action type match based on the RTK action creator\n  actionCreator?: ActionCreator\n\n  // 3) Match one of many actions using an RTK matcher\n  matcher?: Matcher\n\n  // 4) Return true based on a combination of action + state\n  predicate?: ListenerPredicate\n\n  // The actual callback to run when the action is matched\n  effect: (action: Action, listenerApi: ListenerApi) => void | Promise<void>\n}\n\ntype ListenerPredicate<Action extends AnyAction, State> = (\n  action: Action,\n  currentState?: State,\n  originalState?: State\n) => boolean\n\ntype UnsubscribeListener = (\n  unsubscribeOptions?: UnsubscribeListenerOptions\n) => void\n\ninterface UnsubscribeListenerOptions {\n  cancelActive?: true\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"You must provide exactly ",(0,r.kt)("em",{parentName:"strong"},"one")," of the four options for deciding when the listener will run: ",(0,r.kt)("inlineCode",{parentName:"strong"},"type"),", ",(0,r.kt)("inlineCode",{parentName:"strong"},"actionCreator"),", ",(0,r.kt)("inlineCode",{parentName:"strong"},"matcher"),", or ",(0,r.kt)("inlineCode",{parentName:"strong"},"predicate")),". Every time an action is dispatched, each listener will be checked to see if it should run based on the current action vs the comparison option provided."),(0,r.kt)("p",null,"These are all acceptable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// 1) Action type string\nlistenerMiddleware.startListening({ type: 'todos/todoAdded', effect })\n// 2) RTK action creator\nlistenerMiddleware.startListening({ actionCreator: todoAdded, effect })\n// 3) RTK matcher function\nlistenerMiddleware.startListening({\n  matcher: isAnyOf(todoAdded, todoToggled),\n  effect,\n})\n// 4) Listener predicate\nlistenerMiddleware.startListening({\n  predicate: (action, currentState, previousState) => {\n    // return true when the listener should run\n  },\n  effect,\n})\n")),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate"),' option actually allows matching solely against state-related checks, such as "did ',(0,r.kt)("inlineCode",{parentName:"p"},"state.x"),' change" or "the current value of ',(0,r.kt)("inlineCode",{parentName:"p"},"state.x"),' matches some criteria", regardless of the actual action.'),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/api/matching-utilities"},'"matcher" utility functions included in RTK')," are acceptable as either the ",(0,r.kt)("inlineCode",{parentName:"p"},"matcher")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," option."),(0,r.kt)("p",null,"The return value is an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsubscribe()")," callback that will remove this listener. By default, unsubscribing will ",(0,r.kt)("em",{parentName:"p"},"not")," cancel any active instances of the listener. However, you may also pass in ",(0,r.kt)("inlineCode",{parentName:"p"},"{cancelActive: true}")," to cancel running instances."),(0,r.kt)("p",null,"If you try to add a listener entry but another entry with this exact function reference already exists, no new entry will be added, and the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"unsubscribe")," method will be returned."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"effect"),' callback will receive the current action as its first argument, as well as a "listener API" object similar to the "thunk API" object in ',(0,r.kt)("inlineCode",{parentName:"p"},"createAsyncThunk"),"."),(0,r.kt)("p",null,"All listener predicates and callbacks are checked ",(0,r.kt)("em",{parentName:"p"},"after")," the root reducer has already processed the action and updated the state. The ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi.getOriginalState()")," method can be used to get the state value that existed before the action that triggered this listener was processed."),(0,r.kt)("h3",{id:"stoplistening"},(0,r.kt)("inlineCode",{parentName:"h3"},"stopListening")),(0,r.kt)("p",null,"Removes a given listener entry."),(0,r.kt)("p",null,"It accepts the same arguments as ",(0,r.kt)("inlineCode",{parentName:"p"},"startListening()"),". It checks for an existing listener entry by comparing the function references of ",(0,r.kt)("inlineCode",{parentName:"p"},"listener")," and the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"actionCreator/matcher/predicate")," function or ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," string."),(0,r.kt)("p",null,"By default, this does ",(0,r.kt)("em",{parentName:"p"},"not")," cancel any active running instances. However, you may also pass in ",(0,r.kt)("inlineCode",{parentName:"p"},"{cancelActive: true}")," to cancel running instances."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const stopListening = (\n  options: AddListenerOptions & UnsubscribeListenerOptions\n) => boolean\n\ninterface UnsubscribeListenerOptions {\n  cancelActive?: true\n}\n")),(0,r.kt)("p",null,"Returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the listener entry has been removed, or ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if no subscription matching the input provided has been found."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Examples:\n// 1) Action type string\nlistenerMiddleware.stopListening({\n  type: 'todos/todoAdded',\n  listener,\n  cancelActive: true,\n})\n// 2) RTK action creator\nlistenerMiddleware.stopListening({ actionCreator: todoAdded, effect })\n// 3) RTK matcher function\nlistenerMiddleware.stopListening({ matcher, effect, cancelActive: true })\n// 4) Listener predicate\nlistenerMiddleware.stopListening({ predicate, effect })\n")),(0,r.kt)("h3",{id:"clearlisteners"},(0,r.kt)("inlineCode",{parentName:"h3"},"clearListeners")),(0,r.kt)("p",null,"Removes all current listener entries. It also cancels all active running instances of those listeners as well."),(0,r.kt)("p",null,"This is most likely useful for test scenarios where a single middleware or store instance might be used in multiple tests, as well as some app cleanup situations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const clearListeners = () => void;\n")),(0,r.kt)("h2",{id:"action-creators"},"Action Creators"),(0,r.kt)("p",null,'In addition to adding and removing listeners by directly calling methods on the listener instance, you can dynamically add and remove listeners at runtime by dispatching special "add" and "remove" actions. These are exported from the main RTK package as standard RTK-generated action creators.'),(0,r.kt)("h3",{id:"addlistener"},(0,r.kt)("inlineCode",{parentName:"h3"},"addListener")),(0,r.kt)("p",null,"A standard RTK action creator, imported from the package. Dispatching this action tells the middleware to dynamically add a new listener at runtime. It accepts exactly the same options as ",(0,r.kt)("inlineCode",{parentName:"p"},"startListening()")),(0,r.kt)("p",null,"Dispatching this action returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsubscribe()")," callback from ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Per above, provide `predicate` or any of the other comparison options\nconst unsubscribe = store.dispatch(addListener({ predicate, effect }))\n")),(0,r.kt)("h3",{id:"removelistener"},(0,r.kt)("inlineCode",{parentName:"h3"},"removeListener")),(0,r.kt)("p",null,"A standard RTK action creator, imported from the package. Dispatching this action tells the middleware to dynamically remove a listener at runtime. Accepts the same arguments as ",(0,r.kt)("inlineCode",{parentName:"p"},"stopListening()"),"."),(0,r.kt)("p",null,"By default, this does ",(0,r.kt)("em",{parentName:"p"},"not")," cancel any active running instances. However, you may also pass in ",(0,r.kt)("inlineCode",{parentName:"p"},"{cancelActive: true}")," to cancel running instances."),(0,r.kt)("p",null,"Returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the listener entry has been removed, ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if no subscription matching the input provided has been found."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const wasRemoved = store.dispatch(\n  removeListener({ predicate, effect, cancelActive: true })\n)\n")),(0,r.kt)("h3",{id:"clearalllisteners"},(0,r.kt)("inlineCode",{parentName:"h3"},"clearAllListeners")),(0,r.kt)("p",null,"A standard RTK action creator, imported from the package. Dispatching this action tells the middleware to remove all current listener entries. It also cancels all active running instances of those listeners as well."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"store.dispatch(clearAllListeners())\n")),(0,r.kt)("h2",{id:"listener-api"},"Listener API"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi")," object is the second argument to each listener callback. It contains several utility functions that may be called anywhere inside the listener's logic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"export interface ListenerEffectAPI<\n  State,\n  Dispatch extends ReduxDispatch<AnyAction>,\n  ExtraArgument = unknown\n> extends MiddlewareAPI<Dispatch, State> {\n  // NOTE: MiddlewareAPI contains `dispatch` and `getState` already\n\n  /**\n   * Returns the store state as it existed when the action was originally dispatched, _before_ the reducers ran.\n   * This function can **only** be invoked **synchronously**, it throws error otherwise.\n   */\n  getOriginalState: () => State\n  /**\n   * Removes the listener entry from the middleware and prevent future instances of the listener from running.\n   * It does **not** cancel any active instances.\n   */\n  unsubscribe(): void\n  /**\n   * It will subscribe a listener if it was previously removed, noop otherwise.\n   */\n  subscribe(): void\n  /**\n   * Returns a promise that resolves when the input predicate returns `true` or\n   * rejects if the listener has been cancelled or is completed.\n   *\n   * The return value is `true` if the predicate succeeds or `false` if a timeout is provided and expires first.\n   */\n  condition: ConditionFunction<State>\n  /**\n   * Returns a promise that resolves when the input predicate returns `true` or\n   * rejects if the listener has been cancelled or is completed.\n   *\n   * The return value is the `[action, currentState, previousState]` combination that the predicate saw as arguments.\n   *\n   * The promise resolves to null if a timeout is provided and expires first.\n   */\n  take: TakePattern<State>\n  /**\n   * Cancels all other running instances of this same listener except for the one that made this call.\n   */\n  cancelActiveListeners: () => void\n  /**\n   * An abort signal whose `aborted` property is set to `true`\n   * if the listener execution is either aborted or completed.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n   */\n  signal: AbortSignal\n  /**\n   * Returns a promise that resolves after `timeoutMs` or\n   * rejects if the listener has been cancelled or is completed.\n   */\n  delay(timeoutMs: number): Promise<void>\n  /**\n   * Queues in the next microtask the execution of a task.\n   */\n  fork<T>(executor: ForkedTaskExecutor<T>): ForkedTask<T>\n  /**\n   * Returns a promise that resolves when `waitFor` resolves or\n   * rejects if the listener has been cancelled or is completed.\n   * @param promise\n   */\n  pause<M>(promise: Promise<M>): Promise<M>\n  extra: ExtraArgument\n}\n")),(0,r.kt)("p",null,"These can be divided into several categories."),(0,r.kt)("h3",{id:"store-interaction-methods"},"Store Interaction Methods"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dispatch: Dispatch"),": the standard ",(0,r.kt)("inlineCode",{parentName:"li"},"store.dispatch")," method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getState: () => State"),": the standard ",(0,r.kt)("inlineCode",{parentName:"li"},"store.getState")," method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getOriginalState: () => State"),": returns the store state as it existed when the action was originally dispatched, ",(0,r.kt)("em",{parentName:"li"},"before")," the reducers ran. (",(0,r.kt)("strong",{parentName:"li"},"Note"),": this method can only be called synchronously, during the initial dispatch call stack, to avoid memory leaks. Calling it asynchronously will throw an error.)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extra: unknown"),': the "extra argument" that was provided as part of the middleware setup, if any')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dispatch")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getState")," are exactly the same as in a thunk. ",(0,r.kt)("inlineCode",{parentName:"p"},"getOriginalState")," can be used to compare the original state before the listener was started."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"extra")," can be used to inject a value such as an API service layer into the middleware at creation time, and is accessible here."),(0,r.kt)("h3",{id:"listener-subscription-management"},"Listener Subscription Management"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unsubscribe: () => void"),": removes the listener entry from the middleware, and prevent future instances of the listener from running. (This does ",(0,r.kt)("em",{parentName:"li"},"not")," cancel any active instances.)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"subscribe: () => void"),": will re-subscribe the listener entry if it was previously removed, or no-op if currently subscribed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cancelActiveListeners: () => void"),": cancels all other running instances of this same listener ",(0,r.kt)("em",{parentName:"li"},"except")," for the one that made this call. (The cancellation will only have a meaningful effect if the other instances are paused using one of the cancellation-aware APIs like ",(0,r.kt)("inlineCode",{parentName:"li"},"take/cancel/pause/delay"),' - see "Cancelation and Task Management" in the "Usage" section for more details)'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signal: AbortSignal"),": An ",(0,r.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal"},(0,r.kt)("inlineCode",{parentName:"a"},"AbortSignal"))," whose ",(0,r.kt)("inlineCode",{parentName:"li"},"aborted")," property will be set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," if the listener execution is aborted or completed.")),(0,r.kt)("p",null,"Dynamically unsubscribing and re-subscribing this listener allows for more complex async workflows, such as avoiding duplicate running instances by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi.unsubscribe()")," at the start of a listener, or calling ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi.cancelActiveListeners()")," to ensure that only the most recent instance is allowed to complete."),(0,r.kt)("h3",{id:"conditional-workflow-execution"},"Conditional Workflow Execution"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"take: (predicate: ListenerPredicate, timeout?: number) => Promise<[Action, State, State] | null>"),": returns a promise that will resolve when the ",(0,r.kt)("inlineCode",{parentName:"li"},"predicate")," returns ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),". The return value is the ",(0,r.kt)("inlineCode",{parentName:"li"},"[action, currentState, previousState]")," combination that the predicate saw as arguments. If a ",(0,r.kt)("inlineCode",{parentName:"li"},"timeout")," is provided and expires first, the promise resolves to ",(0,r.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"condition: (predicate: ListenerPredicate, timeout?: number) => Promise<boolean>"),": Similar to ",(0,r.kt)("inlineCode",{parentName:"li"},"take"),", but resolves to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," if the predicate succeeds, and ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," if a ",(0,r.kt)("inlineCode",{parentName:"li"},"timeout"),' is provided and expires first. This allows async logic to pause and wait for some condition to occur before continuing. See "Writing Async Workflows" below for details on usage.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"delay: (timeoutMs: number) => Promise<void>"),": returns a cancellation-aware promise that resolves after the timeout, or rejects if cancelled before the expiration"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pause: (promise: Promise<T>) => Promise<T>"),": accepts any promise, and returns a cancellation-aware promise that either resolves with the argument promise or rejects if cancelled before the resolution")),(0,r.kt)("p",null,"These methods provide the ability to write conditional logic based on future dispatched actions and state changes. Both also accept an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"timeout")," in milliseconds."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"take")," resolves to a ",(0,r.kt)("inlineCode",{parentName:"p"},"[action, currentState, previousState]")," tuple or ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," if it timed out, whereas ",(0,r.kt)("inlineCode",{parentName:"p"},"condition")," resolves to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if it succeeded or ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if timed out."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"take"),' is meant for "wait for an action and get its contents", while ',(0,r.kt)("inlineCode",{parentName:"p"},"condition")," is meant for checks like ",(0,r.kt)("inlineCode",{parentName:"p"},"if (await condition(predicate))"),"."),(0,r.kt)("p",null,"Both these methods are cancellation-aware, and will throw a ",(0,r.kt)("inlineCode",{parentName:"p"},"TaskAbortError")," if the listener instance is cancelled while paused."),(0,r.kt)("h3",{id:"child-tasks"},"Child Tasks"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fork: (executor: (forkApi: ForkApi) => T | Promise<T>) => ForkedTask<T>"),': Launches a "child task" that may be used to accomplish additional work. Accepts any sync or async function as its argument, and returns a ',(0,r.kt)("inlineCode",{parentName:"li"},"{result, cancel}")," object that can be used to check the final status and return value of the child task, or cancel it while in-progress.")),(0,r.kt)("p",null,"Child tasks can be launched, and waited on to collect their return values. The provided ",(0,r.kt)("inlineCode",{parentName:"p"},"executor")," function will be called asynchronously with a ",(0,r.kt)("inlineCode",{parentName:"p"},"forkApi")," object containing ",(0,r.kt)("inlineCode",{parentName:"p"},"{pause, delay, signal}"),", allowing it to pause or check cancellation status. It can also make use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi")," from the listener's scope."),(0,r.kt)("p",null,"An example of this might be a listener that forks a child task containing an infinite loop that listens for events from a server. The parent then uses ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi.condition()"),' to wait for a "stop" action, and cancels the child task.'),(0,r.kt)("p",null,"The task and result types are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"interface ForkedTaskAPI {\n  pause<W>(waitFor: Promise<W>): Promise<W>\n  delay(timeoutMs: number): Promise<void>\n  signal: AbortSignal\n}\n\nexport type TaskResolved<T> = {\n  readonly status: 'ok'\n  readonly value: T\n}\n\nexport type TaskRejected = {\n  readonly status: 'rejected'\n  readonly error: unknown\n}\n\nexport type TaskCancelled = {\n  readonly status: 'cancelled'\n  readonly error: TaskAbortError\n}\n\nexport type TaskResult<Value> =\n  | TaskResolved<Value>\n  | TaskRejected\n  | TaskCancelled\n\nexport interface ForkedTask<T> {\n  result: Promise<TaskResult<T>>\n  cancel(): void\n}\n")),(0,r.kt)("h2",{id:"typescript-usage"},"TypeScript Usage"),(0,r.kt)("p",null,"The middleware code is fully TS-typed. However, the ",(0,r.kt)("inlineCode",{parentName:"p"},"startListening")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"addListener")," functions do not know what the store's ",(0,r.kt)("inlineCode",{parentName:"p"},"RootState")," type looks like by default, so ",(0,r.kt)("inlineCode",{parentName:"p"},"getState()")," will return ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),"."),(0,r.kt)("p",null,'To fix this, the middleware provides types for defining "pre-typed" versions of those methods, similar to the pattern used for defing pre-typed React-Redux hooks. We specifically recommend creating the middleware instance in a separate file from the actual ',(0,r.kt)("inlineCode",{parentName:"p"},"configureStore()")," call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"// listenerMiddleware.ts\nimport { createListenerMiddleware, addListener } from '@reduxjs/toolkit'\nimport type { TypedStartListening, TypedAddListener } from '@reduxjs/toolkit'\n\nimport type { RootState, AppDispatch } from './store'\n\nexport const listenerMiddleware = createListenerMiddleware()\n\nexport type AppStartListening = TypedStartListening<RootState, AppDispatch>\n\nexport const startAppListening =\n  listenerMiddleware.startListening as AppStartListening\n\nexport const addAppListener = addListener as TypedAddListener<\n  RootState,\n  AppDispatch\n>\n")),(0,r.kt)("p",null,"Then import and use those pre-typed methods in your components."),(0,r.kt)("h2",{id:"usage-guide"},"Usage Guide"),(0,r.kt)("h3",{id:"overall-purpose"},"Overall Purpose"),(0,r.kt)("p",null,"This middleware lets you run additional logic when some action is dispatched, as a lighter-weight alternative to middleware like sagas and observables that have both a heavy runtime bundle cost and a large conceptual overhead."),(0,r.kt)("p",null,"This middleware is not intended to handle all possible use cases. Like thunks, it provides you with a basic set of primitives (including access to ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getState"),"), and gives you freedom to write any sync or async logic you want. This is both a strength (you can do anything!) and a weakness (you can do anything, with no guard rails!)."),(0,r.kt)("p",null,"The middleware includes several async workflow primitives that are sufficient to write equivalents to many Redux-Saga effects operators like ",(0,r.kt)("inlineCode",{parentName:"p"},"takeLatest"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"takeLeading"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"debounce"),", although none of those methods are directly included. (See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-toolkit/blob/03eafd5236f16574935cdf1c5958e32ee8cf3fbe/packages/toolkit/src/listenerMiddleware/tests/effectScenarios.test.ts#L74-L363"},"the listener middleware tests file for examples of how to write code equivalent to those effects"),".)"),(0,r.kt)("h3",{id:"standard-usage-patterns"},"Standard Usage Patterns"),(0,r.kt)("p",null,'The most common expected usage is "run some logic after a given action was dispatched". For example, you could set up a simple analytics tracker by looking for certain actions and sending extracted data to the server, including pulling user details from the store:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"listenerMiddleware.startListening({\n  matcher: isAnyOf(action1, action2, action3),\n  effect: (action, listenerApi) => {\n    const user = selectUserDetails(listenerApi.getState())\n\n    const { specialData } = action.meta\n\n    analyticsApi.trackUsage(action.type, user, specialData)\n  },\n})\n")),(0,r.kt)("p",null,"However, the ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," option also allows triggering logic when some state value has changed, or when the state matches a particular condition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"listenerMiddleware.startListening({\n  predicate: (action, currentState, previousState) => {\n    // Trigger logic whenever this field changes\n    return currentState.counter.value !== previousState.counter.value\n  },\n  effect,\n})\n\nlistenerMiddleware.startListening({\n  predicate: (action, currentState, previousState) => {\n    // Trigger logic after every action if this condition is true\n    return currentState.counter.value > 3\n  },\n  effect,\n})\n")),(0,r.kt)("p",null,"You could also implement a generic API fetching capability, where the UI dispatches a plain action describing the type of resource to be requested, and the middleware automatically fetches it and dispatches a result action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"listenerMiddleware.startListening({\n  actionCreator: resourceRequested,\n  effect: async (action, listenerApi) => {\n    const { name, args } = action.payload\n    listenerApi.dispatch(resourceLoading())\n\n    const res = await serverApi.fetch(`/api/${name}`, ...args)\n    listenerApi.dispatch(resourceLoaded(res.data))\n  },\n})\n")),(0,r.kt)("p",null,"(That said, we would recommend use of RTK Query for any meaningful data fetching behavior - this is primarily an example of what you ",(0,r.kt)("em",{parentName:"p"},"could")," do in a listener.)"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi.unsubscribe")," method may be used at any time, and will remove the listener from handling any future actions. As an example, you could create a one-shot listener by unconditionally calling ",(0,r.kt)("inlineCode",{parentName:"p"},"unsubscribe()")," in the body - the effect callback would run the first time the relevant action is seen, then immediately unsubscribe and never run again. (The middleware actually uses this technique internally for the ",(0,r.kt)("inlineCode",{parentName:"p"},"take/condition")," methods)"),(0,r.kt)("h3",{id:"writing-async-workflows-with-conditions"},"Writing Async Workflows with Conditions"),(0,r.kt)("p",null,"One of the great strengths of both sagas and observables is their support for complex async workflows, including stopping and starting behavior based on specific dispatched actions. However, the weakness is that both require mastering a complex API with many unique operators (effects methods like ",(0,r.kt)("inlineCode",{parentName:"p"},"call()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"fork()")," for sagas, RxJS operators for observables), and both add a significant amount to application bundle size."),(0,r.kt)("p",null,"While the listener middleware is ",(0,r.kt)("em",{parentName:"p"},"not")," meant to fully replace sagas or observables, it does provide a carefully chosen set of APIs to implement long-running async workflows as well."),(0,r.kt)("p",null,"Listeners can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"condition")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"take")," methods in ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi")," to wait until some action is dispatched or state check is met. The ",(0,r.kt)("inlineCode",{parentName:"p"},"condition")," method is directly inspired by ",(0,r.kt)("a",{parentName:"p",href:"https://docs.temporal.io/docs/typescript/workflows/#condition"},"the ",(0,r.kt)("inlineCode",{parentName:"a"},"condition")," function in Temporal.io's workflow API")," (credit to ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/swyx"},"@swyx")," for the suggestion!), and ",(0,r.kt)("inlineCode",{parentName:"p"},"take")," is inspired by ",(0,r.kt)("a",{parentName:"p",href:"https://redux-saga.js.org/docs/api#takepattern"},"the ",(0,r.kt)("inlineCode",{parentName:"a"},"take")," effect from Redux-Saga"),"."),(0,r.kt)("p",null,"The signatures are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"type ConditionFunction<Action extends AnyAction, State> = (\n  predicate: ListenerPredicate<Action, State> | (() => boolean),\n  timeout?: number\n) => Promise<boolean>\n\ntype TakeFunction<Action extends AnyAction, State> = (\n  predicate: ListenerPredicate<Action, State> | (() => boolean),\n  timeout?: number\n) => Promise<[Action, State, State] | null>\n")),(0,r.kt)("p",null,"You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"await condition(somePredicate)")," as a way to pause execution of your listener callback until some criteria is met."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," will be called after every action is processed by the reducers, and should return ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," when the condition should resolve. (It is effectively a one-shot listener itself.) If a ",(0,r.kt)("inlineCode",{parentName:"p"},"timeout")," number (in ms) is provided, the promise will resolve ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," returns first, or ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if the timeout expires. This allows you to write comparisons like ",(0,r.kt)("inlineCode",{parentName:"p"},"if (await condition(predicate, timeout))"),"."),(0,r.kt)("p",null,"This should enable writing longer-running workflows with more complex async logic, such as ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/redux-saga/redux-saga/blob/1ecb1bed867eeafc69757df8acf1024b438a79e0/examples/cancellable-counter/src/sagas/index.js"},'the "cancellable counter" example from Redux-Saga'),"."),(0,r.kt)("p",null,"An example of ",(0,r.kt)("inlineCode",{parentName:"p"},"condition")," usage, from the test suite:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"test('condition method resolves promise when there is a timeout', async () => {\n  let finalCount = 0\n  let listenerStarted = false\n\n  listenerMiddleware.startListening({\n    predicate: (action, currentState: CounterState) => {\n      return increment.match(action) && currentState.value === 0\n    },\n    effect: async (action, listenerApi) => {\n      listenerStarted = true\n      // Wait for either the counter to hit 3, or 50ms to elapse\n      const result = await listenerApi.condition(\n        (action, currentState: CounterState) => {\n          return currentState.value === 3\n        },\n        50\n      )\n\n      // In this test, we expect the timeout to happen first\n      expect(result).toBe(false)\n      // Save the state for comparison outside the listener\n      const latestState = listenerApi.getState()\n      finalCount = latestState.value\n    },\n  })\n\n  store.dispatch(increment())\n  // The listener should have started right away\n  expect(listenerStarted).toBe(true)\n\n  store.dispatch(increment())\n\n  // If we wait 150ms, the condition timeout will expire first\n  await delay(150)\n  // Update the state one more time to confirm the listener isn't checking it\n  store.dispatch(increment())\n\n  // Handled the state update before the delay, but not after\n  expect(finalCount).toBe(2)\n})\n")),(0,r.kt)("h3",{id:"cancellation-and-task-management"},"Cancellation and Task Management"),(0,r.kt)("p",null,"The listener middleware supports cancellation of running listener instances, ",(0,r.kt)("inlineCode",{parentName:"p"},"take/condition/pause/delay"),' functions, and "child tasks", with an implementation based on ',(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortController"},(0,r.kt)("inlineCode",{parentName:"a"},"AbortController")),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi.pause/delay()")," functions provide a cancellation-aware way to have the current listener sleep. ",(0,r.kt)("inlineCode",{parentName:"p"},"pause()")," accepts a promise, while ",(0,r.kt)("inlineCode",{parentName:"p"},"delay")," accepts a timeout value. If the listener is cancelled while waiting, a ",(0,r.kt)("inlineCode",{parentName:"p"},"TaskAbortError")," will be thrown. In addition, both ",(0,r.kt)("inlineCode",{parentName:"p"},"take")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"condition")," support cancellation interruption as well."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"listenerApi.fork()"),' can used to launch "child tasks" that can do additional work. These can be waited on to collect their results. An example of this might look like:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"listenerMiddleware.startListening({\n  actionCreator: increment,\n  effect: async (action, listenerApi) => {\n    // Spawn a child task and start it immediately\n    const task = listenerApi.fork(async (forkApi) => {\n      // Artificially wait a bit inside the child\n      await forkApi.delay(5)\n      // Complete the child by returning a value\n      return 42\n    })\n\n    const result = await task.result\n    // Unwrap the child result in the listener\n    if (result.status === 'ok') {\n      // Logs the `42` result value that was returned\n      console.log('Child succeeded: ', result.value)\n    }\n  },\n})\n")),(0,r.kt)("h3",{id:"complex-async-workflows"},"Complex Async Workflows"),(0,r.kt)("p",null,"The provided async workflow primitives (",(0,r.kt)("inlineCode",{parentName:"p"},"cancelActiveListeners"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"unsubscribe"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"take"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"condition"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"pause"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"delay"),") can be used to implement behavior that is equivalent to many of the more complex async workflow capabilities found in the Redux-Saga library. This includes effects such as ",(0,r.kt)("inlineCode",{parentName:"p"},"throttle"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"debounce"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"takeLatest"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"takeLeading"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"fork/join"),". Some examples from the test suite:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"test('debounce / takeLatest', async () => {\n  // Repeated calls cancel previous ones, no work performed\n  // until the specified delay elapses without another call\n  // NOTE: This is also basically identical to `takeLatest`.\n  // Ref: https://redux-saga.js.org/docs/api#debouncems-pattern-saga-args\n  // Ref: https://redux-saga.js.org/docs/api#takelatestpattern-saga-args\n\n  listenerMiddleware.startListening({\n    actionCreator: increment,\n    effect: async (action, listenerApi) => {\n      // Cancel any in-progress instances of this listener\n      listenerApi.cancelActiveListeners()\n\n      // Delay before starting actual work\n      await listenerApi.delay(15)\n\n      // do work here\n    },\n  })\n}\n\ntest('takeLeading', async () => {\n  // Starts listener on first action, ignores others until task completes\n  // Ref: https://redux-saga.js.org/docs/api#takeleadingpattern-saga-args\n\n  listenerMiddleware.startListening({\n    actionCreator: increment,\n    effect: async (action, listenerApi) => {\n      listenerCalls++\n\n      // Stop listening for this action\n      listenerApi.unsubscribe()\n\n      // Pretend we're doing expensive work\n\n      // Re-enable the listener\n      listenerApi.subscribe()\n    },\n  })\n})\n\ntest('cancelled', async () => {\n  // cancelled allows checking if the current task was cancelled\n  // Ref: https://redux-saga.js.org/docs/api#cancelled\n\n  let canceledAndCaught = false\n  let canceledCheck = false\n\n  // Example of canceling prior instances conditionally and checking cancellation\n  listenerMiddleware.startListening({\n    matcher: isAnyOf(increment, decrement, incrementByAmount),\n    effect: async (action, listenerApi) => {\n      if (increment.match(action)) {\n        // Have this branch wait around to be cancelled by the other\n        try {\n          await listenerApi.delay(10)\n        } catch (err) {\n          // Can check cancellation based on the exception and its reason\n          if (err instanceof TaskAbortError) {\n            canceledAndCaught = true\n          }\n        }\n      } else if (incrementByAmount.match(action)) {\n        // do a non-cancellation-aware wait\n        await delay(15)\n        if (listenerApi.signal.aborted) {\n          canceledCheck = true\n        }\n      } else if (decrement.match(action)) {\n        listenerApi.cancelActiveListeners()\n      }\n    },\n  })\n})\n")),(0,r.kt)("p",null,"As a more practical example: ",(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/markerikson/5203e71a69fa9dff203c9e27c3d84154"},'this saga-based "long polling" loop'),' repeatedly asks the server for a message and then processes each response. The child loop is started on demand when a "start polling" action is dispatched, and the loop is cancelled when a "stop polling" action is dispatched.'),(0,r.kt)("p",null,"That approach can be implemented via the listener middleware:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"// Track how many times each message was processed by the loop\nconst receivedMessages = {\n  a: 0,\n  b: 0,\n  c: 0,\n}\n\nconst eventPollingStarted = createAction('serverPolling/started')\nconst eventPollingStopped = createAction('serverPolling/stopped')\n\nlistenerMiddleware.startListening({\n  actionCreator: eventPollingStarted,\n  effect: async (action, listenerApi) => {\n    // Only allow one instance of this listener to run at a time\n    listenerApi.unsubscribe()\n\n    // Start a child job that will infinitely loop receiving messages\n    const pollingTask = listenerApi.fork(async (forkApi) => {\n      try {\n        while (true) {\n          // Cancellation-aware pause for a new server message\n          const serverEvent = await forkApi.pause(pollForEvent())\n          // Process the message. In this case, just count the times we've seen this message.\n          if (serverEvent.type in receivedMessages) {\n            receivedMessages[\n              serverEvent.type as keyof typeof receivedMessages\n            ]++\n          }\n        }\n      } catch (err) {\n        if (err instanceof TaskAbortError) {\n          // could do something here to track that the task was cancelled\n        }\n      }\n    })\n\n    // Wait for the \"stop polling\" action\n    await listenerApi.condition(eventPollingStopped.match)\n    pollingTask.cancel()\n  },\n})\n")),(0,r.kt)("h3",{id:"adding-listeners-inside-components"},"Adding Listeners Inside Components"),(0,r.kt)("p",null,"Listeners can be added at runtime via ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(addListener())"),". This means that you can add listeners anywhere you have access to ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch"),", and that includes React components."),(0,r.kt)("p",null,"Since dispatching ",(0,r.kt)("inlineCode",{parentName:"p"},"addListener")," returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsubscribe")," callback, this naturally maps to the behavior of React ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect")," hooks, which let you return a cleanup function. You can add a listener in an effect, and remove the listener when the hook is cleaned up."),(0,r.kt)("p",null,"The basic pattern might look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"useEffect(() => {\n  // Could also just `return dispatch(addListener())` directly, but showing this\n  // as a separate variable to be clear on what's happening\n  const unsubscribe = dispatch(\n    addListener({\n      actionCreator: todoAdded,\n      effect: (action, listenerApi) => {\n        // do some useful logic here\n      },\n    })\n  )\n  return unsubscribe\n}, [])\n")),(0,r.kt)("p",null,"While this pattern is ",(0,r.kt)("em",{parentName:"p"},"possible"),", ",(0,r.kt)("strong",{parentName:"p"},"we do not necessarily ",(0,r.kt)("em",{parentName:"strong"},"recommend")," doing this!")," The React and Redux communities have always tried to emphasize basing behavior on ",(0,r.kt)("em",{parentName:"p"},"state")," as much as possible. Having React components directly tie into the Redux action dispatch pipeline could potentialy lead to codebases that are more difficult to maintain."),(0,r.kt)("p",null,"At the same time, this ",(0,r.kt)("em",{parentName:"p"},"is"),' a valid technique, both in terms of API behavior and potential use cases. It\'s been common to lazy-load sagas as part of a code-split app, and that has often required some complex additional setup work to "inject" sagas. In contrast, ',(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(addListener())")," fits naturally into a React component's lifecycle."),(0,r.kt)("p",null,"So, while we're not specifically encouraging use of this pattern, it's worth documenting here so that users are aware of it as a possibility."),(0,r.kt)("h3",{id:"organizing-listeners-in-files"},"Organizing Listeners in Files"),(0,r.kt)("p",null,"As a starting point, ",(0,r.kt)("strong",{parentName:"p"},"it's best to create the listener middleware in a separate file, such as ",(0,r.kt)("inlineCode",{parentName:"strong"},"app/listenerMiddleware.ts"),", rather than in the same file as the store"),". This avoids any potential circular import problems from other files trying to import ",(0,r.kt)("inlineCode",{parentName:"p"},"middleware.addListener"),"."),(0,r.kt)("p",null,"From there, so far we've come up with three different ways to organize listener functions and setup."),(0,r.kt)("p",null,"First, you can import effect callbacks from slice files into the middleware file, and add the listeners:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="app/listenerMiddleware.ts"',"no-transpile":!0,title:'"app/listenerMiddleware.ts"'},"import { action1, listener1 } from '../features/feature1/feature1Slice'\nimport { action2, listener2 } from '../features/feature2/feature1Slice'\n\nlistenerMiddleware.startListening({ actionCreator: action1, effect: listener1 })\nlistenerMiddleware.startListening({ actionCreator: action2, effect: listener2 })\n")),(0,r.kt)("p",null,"This is probably the simplest option, and mirrors how the store setup pulls together all the slice reducers to create the app."),(0,r.kt)("p",null,"The second option is the opposite: have the slice files import the middleware and directly add their listeners:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile  title="features/feature1/feature1Slice.ts"',"no-transpile":!0,"":!0,title:'"features/feature1/feature1Slice.ts"'},"import { listenerMiddleware } from '../../app/listenerMiddleware'\n\nconst feature1Slice = createSlice(/* */)\nconst { action1 } = feature1Slice.actions\n\nexport default feature1Slice.reducer\n\nlistenerMiddleware.startListening({\n  actionCreator: action1,\n  effect: () => {},\n})\n")),(0,r.kt)("p",null,"This keeps all the logic in the slice, although it does lock the setup into a single middleware instance."),(0,r.kt)("p",null,"The third option is to create a setup function in the slice, but let the listener file call that on startup:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile  title="features/feature1/feature1Slice.ts"',"no-transpile":!0,"":!0,title:'"features/feature1/feature1Slice.ts"'},"import type { AppStartListening } from '../../app/listenerMiddleware'\n\nconst feature1Slice = createSlice(/* */)\nconst { action1 } = feature1Slice.actions\n\nexport default feature1Slice.reducer\n\nexport const addFeature1Listeners = (startListening: AppStartListening) => {\n  startListening({\n    actionCreator: action1,\n    effect: () => {},\n  })\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="app/listenerMiddleware.ts"',"no-transpile":!0,title:'"app/listenerMiddleware.ts"'},"import { addFeature1Listeners } from '../features/feature1/feature1Slice'\n\naddFeature1Listeners(listenerMiddleware.startListening)\n")),(0,r.kt)("p",null,"Feel free to use whichever of these approaches works best in your app."))}u.isMDXComponent=!0}}]);