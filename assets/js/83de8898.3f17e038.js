"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2150],{1993:function(e,t,a){a.r(t),a.d(t,{contentTitle:function(){return p},default:function(){return c},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return d}});var n=a(5773),i=a(808),r=(a(7378),a(5318)),l=(a(517),a(7637),["components"]),s={id:"api-slice-utils",title:"API Slices: Utilities",sidebar_label:"API Slice Utilities",hide_title:!0},p=void 0,o={unversionedId:"rtk-query/api/created-api/api-slice-utils",id:"rtk-query/api/created-api/api-slice-utils",isDocsHomePage:!1,title:"API Slices: Utilities",description:"&nbsp;",source:"@site/../docs/rtk-query/api/created-api/api-slice-utils.mdx",sourceDirName:"rtk-query/api/created-api",slug:"/rtk-query/api/created-api/api-slice-utils",permalink:"/redux-toolkit/rtk-query/api/created-api/api-slice-utils",tags:[],version:"current",lastUpdatedAt:1656216983,formattedLastUpdatedAt:"6/26/2022",frontMatter:{id:"api-slice-utils",title:"API Slices: Utilities",sidebar_label:"API Slice Utilities",hide_title:!0},sidebar:"docs",previous:{title:"Code Splitting",permalink:"/redux-toolkit/rtk-query/api/created-api/code-splitting"},next:{title:"React Hooks",permalink:"/redux-toolkit/rtk-query/api/created-api/hooks"}},d=[{value:"<code>updateQueryData</code>",id:"updatequerydata",children:[{value:"Signature",id:"signature",children:[],level:4},{value:"Description",id:"description",children:[],level:4},{value:"Example 1",id:"example-1",children:[],level:4},{value:"Example 2",id:"example-2",children:[],level:4}],level:3},{value:"<code>patchQueryData</code>",id:"patchquerydata",children:[{value:"Signature",id:"signature-1",children:[],level:4},{value:"Description",id:"description-1",children:[],level:4},{value:"Example",id:"example",children:[],level:4}],level:3},{value:"<code>prefetch</code>",id:"prefetch",children:[{value:"Signature",id:"signature-2",children:[],level:4},{value:"Description",id:"description-2",children:[],level:4},{value:"Example",id:"example-3",children:[],level:4}],level:3},{value:"<code>invalidateTags</code>",id:"invalidatetags",children:[{value:"Signature",id:"signature-3",children:[],level:4},{value:"Description",id:"description-3",children:[],level:4},{value:"Example",id:"example-4",children:[],level:4}],level:3},{value:"<code>resetApiState</code>",id:"resetapistate",children:[{value:"Signature",id:"signature-4",children:[],level:4},{value:"Description",id:"description-4",children:[],level:4},{value:"Example",id:"example-5",children:[],level:4}],level:3},{value:"<code>getRunningOperationPromises</code>",id:"getrunningoperationpromises",children:[{value:"Signature",id:"signature-5",children:[],level:4},{value:"Description",id:"description-5",children:[],level:4}],level:2},{value:"<code>getRunningOperationPromise</code>",id:"getrunningoperationpromise",children:[{value:"Signature",id:"signature-6",children:[],level:4},{value:"Description",id:"description-6",children:[],level:4}],level:2}],u={toc:d};function c(e){var t=e.components,a=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"api-slices-utilities"},"API Slices: Utilities"),(0,r.kt)("p",null,"The API slice object includes various utilities that can be used for cache management,\nsuch as implementing ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/manual-cache-updates#optimistic-updates"},"optimistic updates"),",\nas well implementing ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/server-side-rendering"},"server side rendering"),"."),(0,r.kt)("p",null,"These are included in a ",(0,r.kt)("inlineCode",{parentName:"p"},"util")," field inside the slice object."),(0,r.kt)("h3",{id:"updatequerydata"},(0,r.kt)("inlineCode",{parentName:"h3"},"updateQueryData")),(0,r.kt)("h4",{id:"signature"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const updateQueryData = (\n  endpointName: string,\n  args: any,\n  updateRecipe: (draft: Draft<CachedState>) => void\n) => ThunkAction<PatchCollection, PartialState, any, AnyAction>;\n\ninterface PatchCollection {\n  patches: Patch[];\n  inversePatches: Patch[];\n  undo: () => void;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endpointName"),": a string matching an existing endpoint name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args"),": an argument matching that used for a previous query call, used to determine which cached dataset needs to be updated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updateRecipe"),": an Immer ",(0,r.kt)("inlineCode",{parentName:"li"},"produce")," callback that can apply changes to the cached state")))),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"A Redux thunk action creator that, when dispatched, creates and applies a set of JSON diff/patch objects to the current state. This immediately updates the Redux state with those changes."),(0,r.kt)("p",null,"The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPost'"),"), any relevant query arguments, and a callback function. The callback receives an Immer-wrapped ",(0,r.kt)("inlineCode",{parentName:"p"},"draft")," of the current state, and may modify the draft to match the expected results after the mutation completes successfully."),(0,r.kt)("p",null,"The thunk returns an object containing ",(0,r.kt)("inlineCode",{parentName:"p"},"{patches: Patch[], inversePatches: Patch[], undo: () => void}"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"patches")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," are generated using Immer's ",(0,r.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/patches"},(0,r.kt)("inlineCode",{parentName:"a"},"produceWithPatches")," method"),"."),(0,r.kt)("p",null,"This is typically used as the first step in implementing optimistic updates. The generated ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," can be used to revert the updates by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(patchQueryData(endpointName, args, inversePatches))"),". Alternatively, the ",(0,r.kt)("inlineCode",{parentName:"p"},"undo")," method can be called directly to achieve the same effect."),(0,r.kt)("p",null,"Note that the first two arguments (",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),") are used to determine which existing\ncache entry to update. If no existing cache entry is found, the ",(0,r.kt)("inlineCode",{parentName:"p"},"updateRecipe")," callback will not run."),(0,r.kt)("h4",{id:"example-1"},"Example 1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  })\n)\n")),(0,r.kt)("p",null,"In the example above, ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPosts'")," is provided for the ",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," is provided\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),". This will match a query cache key of ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPosts(undefined)'"),"."),(0,r.kt)("p",null,"i.e. it will match a cache entry that may have been created via any of the following calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"api.endpoints.getPosts.useQuery()\n\nuseGetPostsQuery()\n\nuseGetPostsQuery(undefined, { ...options })\n\ndispatch(api.endpoints.getPosts.initiate())\n\ndispatch(api.endpoints.getPosts.initiate(undefined, { ...options }))\n")),(0,r.kt)("h4",{id:"example-2"},"Example 2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchCollection = dispatch(\n  api.util.updateQueryData('getPostById', 1, (draftPost) => {\n    draftPost.name = 'Lilly'\n  })\n)\n")),(0,r.kt)("p",null,"In the example above, ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPostById'")," is provided for the ",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," is provided\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),". This will match a query cache key of ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPostById(1)'"),"."),(0,r.kt)("p",null,"i.e. it will match a cache entry that may have been created via any of the following calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"api.endpoints.getPostById.useQuery(1)\n\nuseGetPostByIdQuery(1)\n\nuseGetPostByIdQuery(1, { ...options })\n\ndispatch(api.endpoints.getPostById.initiate(1))\n\ndispatch(api.endpoints.getPostById.initiate(1, { ...options }))\n")),(0,r.kt)("h3",{id:"patchquerydata"},(0,r.kt)("inlineCode",{parentName:"h3"},"patchQueryData")),(0,r.kt)("h4",{id:"signature-1"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchQueryData = (\n  endpointName: string,\n  args: any\n  patches: Patch[]\n) => ThunkAction<void, PartialState, any, AnyAction>;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endpointName"),": a string matching an existing endpoint name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args"),": a cache key, used to determine which cached dataset needs to be updated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"patches"),": an array of patches (or inverse patches) to apply to cached state. These would typically be obtained from the result of dispatching ",(0,r.kt)("a",{parentName:"li",href:"#updatequerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"updateQueryData")))))),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"A Redux thunk action creator that applies a JSON diff/patch array to the cached data for a given query result. This immediately updates the Redux state with those changes."),(0,r.kt)("p",null,"The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPost'"),"), any relevant query arguments, and a JSON diff/patch array as produced by Immer's ",(0,r.kt)("inlineCode",{parentName:"p"},"produceWithPatches"),"."),(0,r.kt)("p",null,"This is typically used as the second step in implementing optimistic updates. If a request fails, the optimistically-applied changes can be reverted by dispatching ",(0,r.kt)("inlineCode",{parentName:"p"},"patchQueryData")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," that were generated by ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," earlier."),(0,r.kt)("p",null,"In cases where it is desired to simply revert the previous changes, it may be preferable to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"undo")," method returned from dispatching ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," instead."),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const patchCollection = dispatch(\n  api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n    draftPosts.push({ id: 1, name: 'Teddy' })\n  })\n)\n\n// later\ndispatch(\n  api.util.patchQueryData('getPosts', undefined, patchCollection.inversePatches)\n)\n\n// or\npatchCollection.undo()\n")),(0,r.kt)("h3",{id:"prefetch"},(0,r.kt)("inlineCode",{parentName:"h3"},"prefetch")),(0,r.kt)("h4",{id:"signature-2"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"type PrefetchOptions = { ifOlderThan?: false | number } | { force?: boolean };\n\nconst prefetch = (\n  endpointName: string,\n  arg: any,\n  options: PrefetchOptions\n) => ThunkAction<void, any, any, AnyAction>;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endpointName"),": a string matching an existing endpoint name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args"),": a cache key, used to determine which cached dataset needs to be updated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options"),": options to determine whether the request should be sent for a given situation:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ifOlderThan"),": if specified, only runs the query if the difference between ",(0,r.kt)("inlineCode",{parentName:"li"},"new Date()")," and the last",(0,r.kt)("inlineCode",{parentName:"li"},"fulfilledTimeStamp")," is greater than the given value (in seconds)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"force"),": if ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", it will ignore the ",(0,r.kt)("inlineCode",{parentName:"li"},"ifOlderThan")," value if it is set and the query will be run even if it exists in the cache.")))))),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"A Redux thunk action creator that can be used to manually trigger pre-fetching of data."),(0,r.kt)("p",null,"The thunk action creator accepts three arguments: the name of the endpoint we are updating (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"'getPost'"),"), any relevant query arguments, and a set of options used to determine if the data actually should be re-fetched based on cache staleness."),(0,r.kt)("p",null,"React Hooks users will most likely never need to use this directly, as the ",(0,r.kt)("inlineCode",{parentName:"p"},"usePrefetch")," hook will dispatch the thunk action creator result internally as needed when you call the prefetching function supplied by the hook."),(0,r.kt)("h4",{id:"example-3"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"dispatch(api.util.prefetch('getPosts', undefined, { force: true }))\n")),(0,r.kt)("h3",{id:"invalidatetags"},(0,r.kt)("inlineCode",{parentName:"h3"},"invalidateTags")),(0,r.kt)("h4",{id:"signature-3"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const invalidateTags = (\n  tags: Array<TagTypes | FullTagDescription<TagTypes>>\n) => ({\n  type: string,\n  payload: tags,\n})\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tags"),": an array of tags to be invalidated, where the provided ",(0,r.kt)("inlineCode",{parentName:"li"},"TagType")," is one of the strings provided to the ",(0,r.kt)("a",{parentName:"li",href:"/redux-toolkit/rtk-query/api/createApi#tagtypes"},(0,r.kt)("inlineCode",{parentName:"a"},"tagTypes"))," property of the api. e.g.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[TagType]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[{ type: TagType }]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[{ type: TagType, id: number | string }]"))))))),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"A Redux action creator that can be used to manually invalidate cache tags for ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/automated-refetching"},"automated re-fetching"),"."),(0,r.kt)("p",null,"The action creator accepts one argument: the cache tags to be invalidated. It returns an action with those tags as a payload, and the corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"invalidateTags")," action type for the api."),(0,r.kt)("p",null,"Dispatching the result of this action creator will ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/automated-refetching#invalidating-cache-data"},"invalidate")," the given tags, causing queries to automatically re-fetch if they are subscribed to cache data that ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/automated-refetching#providing-cache-data"},"provides")," the corresponding tags."),(0,r.kt)("h4",{id:"example-4"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"dispatch(api.util.invalidateTags(['Post']))\ndispatch(api.util.invalidateTags([{ type: 'Post', id: 1 }]))\ndispatch(\n  api.util.invalidateTags([\n    { type: 'Post', id: 1 },\n    { type: 'Post', id: 'LIST' },\n  ])\n)\n")),(0,r.kt)("h3",{id:"resetapistate"},(0,r.kt)("inlineCode",{parentName:"h3"},"resetApiState")),(0,r.kt)("h4",{id:"signature-4"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"const resetApiState = () => ({\n  type: string,\n  payload: undefined,\n})\n")),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"A Redux action creator that can be dispatched to manually reset the api state completely. This will immediately remove all existing cache entries, and all queries will be considered 'uninitialized'."),(0,r.kt)("p",null,"Note that ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/created-api/hooks"},"hooks")," also track state in local component state and might not fully be reset by ",(0,r.kt)("inlineCode",{parentName:"p"},"resetApiState"),"."),(0,r.kt)("h4",{id:"example-5"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"dispatch(api.util.resetApiState())\n")),(0,r.kt)("h2",{id:"getrunningoperationpromises"},(0,r.kt)("inlineCode",{parentName:"h2"},"getRunningOperationPromises")),(0,r.kt)("h4",{id:"signature-5"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"getRunningOperationPromises: () => Array<Promise<unknown>>\n")),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"A function that returns all promises for running queries and mutations."),(0,r.kt)("p",null,"This is useful for SSR scenarios to await everything triggered in any way, including via hook calls,\nor manually dispatching ",(0,r.kt)("inlineCode",{parentName:"p"},"initiate")," actions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'no-transpile title="Awaiting all currently running queries & mutations example"',"no-transpile":!0,title:'"Awaiting',all:!0,currently:!0,running:!0,queries:!0,"&":!0,mutations:!0,'example"':!0},"await Promise.all(api.util.getRunningOperationPromises())\n")),(0,r.kt)("h2",{id:"getrunningoperationpromise"},(0,r.kt)("inlineCode",{parentName:"h2"},"getRunningOperationPromise")),(0,r.kt)("h4",{id:"signature-6"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"getRunningOperationPromise: <EndpointName extends QueryKeys<Definitions>>(\n  endpointName: EndpointName,\n  args: QueryArgFrom<Definitions[EndpointName]>\n) =>\n  | QueryActionCreatorResult<Definitions[EndpointName]>\n  | undefined\n\ngetRunningOperationPromise: <EndpointName extends MutationKeys<Definitions>>(\n  endpointName: EndpointName,\n  fixedCacheKeyOrRequestId: string\n) =>\n  | MutationActionCreatorResult<Definitions[EndpointName]>\n  | undefined\n")),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"A function that returns a single promise for a given endpoint name + argument combination,\nif it is currently running. If it is not currently running, the function returns ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,r.kt)("p",null,"When used with mutation endpoints, it accepts a ",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/created-api/hooks#signature-1"},"fixed cache key"),"\nor request ID rather than the argument."),(0,r.kt)("p",null,"This is primarily added to add experimental support for suspense in the future.\nIt enables writing custom hooks that look up if RTK Query has already got a running promise\nfor a certain endpoint/argument combination, and retrieving that promise to ",(0,r.kt)("inlineCode",{parentName:"p"},"throw")," it."))}c.isMDXComponent=!0}}]);