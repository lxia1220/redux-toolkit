"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5334],{9894:function(e,t,a){a.r(t),a.d(t,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return p},metadata:function(){return u},toc:function(){return c}});var n=a(5773),i=a(808),r=(a(7378),a(5318)),s=a(517),o=a(7637),d=["components"],p={id:"manual-cache-updates",title:"Manual Cache Updates",sidebar_label:"Manual Cache Updates",hide_title:!0,description:"RTK Query > \uc0ac\uc6a9\ubc95 > Manual Cache Updates: Updating cached data manually"},l=void 0,u={unversionedId:"rtk-query/usage/manual-cache-updates",id:"rtk-query/usage/manual-cache-updates",isDocsHomePage:!1,title:"Manual Cache Updates",description:"RTK Query > \uc0ac\uc6a9\ubc95 > Manual Cache Updates: Updating cached data manually",source:"@site/../docs/rtk-query/usage/manual-cache-updates.mdx",sourceDirName:"rtk-query/usage",slug:"/rtk-query/usage/manual-cache-updates",permalink:"/redux-toolkit/rtk-query/usage/manual-cache-updates",tags:[],version:"current",lastUpdatedAt:1656216983,formattedLastUpdatedAt:"6/26/2022",frontMatter:{id:"manual-cache-updates",title:"Manual Cache Updates",sidebar_label:"Manual Cache Updates",hide_title:!0,description:"RTK Query > \uc0ac\uc6a9\ubc95 > Manual Cache Updates: Updating cached data manually"},sidebar:"docs",previous:{title:"Automated Re-fetching",permalink:"/redux-toolkit/rtk-query/usage/automated-refetching"},next:{title:"Conditional Fetching",permalink:"/redux-toolkit/rtk-query/usage/conditional-fetching"}},c=[{value:"Overview",id:"overview",children:[],level:2},{value:"Recipes",id:"recipes",children:[{value:"Optimistic Updates",id:"optimistic-updates",children:[{value:"Example",id:"example",children:[],level:4}],level:3},{value:"Pessimistic Updates",id:"pessimistic-updates",children:[],level:3},{value:"General Updates",id:"general-updates",children:[],level:3}],level:2}],h={toc:c};function m(e){var t=e.components,a=(0,i.Z)(e,d);return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"manual-cache-updates"},"Manual Cache Updates"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"For most cases, in order to receive up to date data after a triggering a change in the backend,\nyou can take advantage of ",(0,r.kt)("inlineCode",{parentName:"p"},"cache tag invalidation")," to perform\n",(0,r.kt)("a",{parentName:"p",href:"./automated-refetching"},"automated re-fetching"),", which will cause a query to re-fetch its data\nwhen it has been told that a mutation has occurred which would cause its data to become out of date.\nIn most cases, we recommend using ",(0,r.kt)("inlineCode",{parentName:"p"},"automated re-fetching")," as a preference over ",(0,r.kt)("inlineCode",{parentName:"p"},"manual cache updates"),",\nunless you encounter the need to do so."),(0,r.kt)("p",null,"\uadf8\ub7ec\ub098 \uba87\uba87 \uacbd\uc6b0\uc5d4 \uce90\uc2dc\ub97c \uc218\ub3d9\uc73c\ub85c \uc5c5\ub370\uc774\ud2b8\ud558\uace0 \uc2f6\uc744 \ub54c\uac00 \uc788\uc2b5\ub2c8\ub2e4. When you wish to update cache\ndata that ",(0,r.kt)("em",{parentName:"p"},"already exists")," for query endpoints, you can do so using the\n",(0,r.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/created-api/api-slice-utils#updatequerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"updateQueryData"))," thunk action\navailable on the ",(0,r.kt)("inlineCode",{parentName:"p"},"util")," object of your created API."),(0,r.kt)("p",null,"Anywhere you have access to the ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch")," method for the store instance, you can dispatch the\nresult of calling ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," in order to update the cache data for a query endpoint,\nif the corresponding cache entry exists."),(0,r.kt)("p",null,"Use cases for manual cache updates include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Providing immediate feedback to the user when a mutation is attempted"),(0,r.kt)("li",{parentName:"ul"},"After a mutation, updating a single item in a large list of items that is already cached,\nrather than re-fetching the whole list"),(0,r.kt)("li",{parentName:"ul"},"Debouncing a large number of mutations with immediate feedback as though they are being\napplied, followed by a single request sent to the server to update the debounced attempts")),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," is strictly intended to perform ",(0,r.kt)("em",{parentName:"p"},"updates")," to existing cache entries,\nnot create new entries. If an ",(0,r.kt)("inlineCode",{parentName:"p"},"updateQueryData")," thunk action is dispatched that corresponds to\nno existing cache entry for the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"endpointName")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," combination, the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"recipe"),"\nwill not be called, and no ",(0,r.kt)("inlineCode",{parentName:"p"},"patches")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"inversePatches")," will be returned."))),(0,r.kt)("h2",{id:"recipes"},"Recipes"),(0,r.kt)("h3",{id:"optimistic-updates"},"Optimistic Updates"),(0,r.kt)("p",null,"When you wish to perform an update to cache data immediately after a ",(0,r.kt)("a",{parentName:"p",href:"./mutations"},(0,r.kt)("inlineCode",{parentName:"a"},"mutation"))," is\ntriggered, you can apply an ",(0,r.kt)("inlineCode",{parentName:"p"},"optimistic update"),". This can be a useful pattern for when you want to\ngive the user the impression that their changes are immediate, even while the mutation request is\nstill in flight."),(0,r.kt)("p",null,"The core concepts for an optimistic update are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when you start a query or mutation, ",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted")," will be executed"),(0,r.kt)("li",{parentName:"ul"},"you manually update the cached data by dispatching ",(0,r.kt)("inlineCode",{parentName:"li"},"api.util.updateQueryData")," within ",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted")),(0,r.kt)("li",{parentName:"ul"},"then, in the case that ",(0,r.kt)("inlineCode",{parentName:"li"},"queryFulfilled")," rejects:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"you roll it back via the ",(0,r.kt)("inlineCode",{parentName:"li"},".undo")," property of the object you got back from the earlier dispatch,",(0,r.kt)("br",{parentName:"li"}),"OR"),(0,r.kt)("li",{parentName:"ul"},"you invalidate the cache data via ",(0,r.kt)("inlineCode",{parentName:"li"},"api.util.invalidateTags")," to trigger a full re-fetch of the data")))),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Where many mutations are potentially triggered in short succession causing overlapping requests,\nyou may encounter race conditions if attempting to roll back patches using the ",(0,r.kt)("inlineCode",{parentName:"p"},".undo")," property\non failures. For these scenarios, it is often simplest and safest to invalidate the tags on error\ninstead, and re-fetch truly up-to-date data from the server."))),(0,r.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Optimistic update mutation example (async await)"',title:'"Optimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<void, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n\n          /**\n           * Alternatively, on failure you can invalidate the corresponding cache tags\n           * to trigger a re-fetch:\n           * dispatch(api.util.invalidateTags(['Post']))\n           */\n        }\n      },\n      // highlight-end\n    }),\n  }),\n})\n"))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Optimistic update mutation example (async await)"',title:'"Optimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n        try {\n          await queryFulfilled\n        } catch {\n          patchResult.undo()\n\n          /**\n           * Alternatively, on failure you can invalidate the corresponding cache tags\n           * to trigger a re-fetch:\n           * dispatch(api.util.invalidateTags(['Post']))\n           */\n        }\n      },\n      // highlight-end\n    }),\n  }),\n})\n")))),(0,r.kt)("p",null,"or, if you prefer the slightly shorter version with ",(0,r.kt)("inlineCode",{parentName:"p"},".catch")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n+      onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          api.util.updateQueryData('getPost', id, (draft) => {\n            Object.assign(draft, patch)\n          })\n        )\n-       try {\n-         await queryFulfilled\n-       } catch {\n-         patchResult.undo()\n-       }\n+       queryFulfilled.catch(patchResult.undo)\n      }\n")),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./examples#react-optimistic-updates"},"React Optimistic Updates")),(0,r.kt)("h3",{id:"pessimistic-updates"},"Pessimistic Updates"),(0,r.kt)("p",null,"When you wish to perform an update to cache data based on the response received from the server\nafter a ",(0,r.kt)("a",{parentName:"p",href:"./mutations"},(0,r.kt)("inlineCode",{parentName:"a"},"mutation"))," is triggered, you can apply a ",(0,r.kt)("inlineCode",{parentName:"p"},"pessimistic update"),".\nThe distinction between a ",(0,r.kt)("inlineCode",{parentName:"p"},"pessimistic update")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"optimistic update")," is that the\n",(0,r.kt)("inlineCode",{parentName:"p"},"pessimistic update")," will instead wait for the response from the server prior to updating\nthe cached data."),(0,r.kt)("p",null,"The core concepts for a pessimistic update are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when you start a query or mutation, ",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted")," will be executed"),(0,r.kt)("li",{parentName:"ul"},"you await ",(0,r.kt)("inlineCode",{parentName:"li"},"queryFulfilled")," to resolve to an object containing the transformed response from the\nserver in the ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," property"),(0,r.kt)("li",{parentName:"ul"},"you manually update the cached data by dispatching ",(0,r.kt)("inlineCode",{parentName:"li"},"api.util.updateQueryData")," within\n",(0,r.kt)("inlineCode",{parentName:"li"},"onQueryStarted"),", using the data in the response from the server for your draft updates")),(0,r.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Pessimistic update mutation example (async await)"',title:'"Pessimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { Post } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query<Post, number>({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation<Post, Pick<Post, 'id'> & Partial<Post>>({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            })\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n  }),\n})\n"))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Pessimistic update mutation example (async await)"',title:'"Pessimistic',update:!0,mutation:!0,example:!0,"(async":!0,'await)"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({\n    baseUrl: '/',\n  }),\n  tagTypes: ['Post'],\n  endpoints: (build) => ({\n    getPost: build.query({\n      query: (id) => `post/${id}`,\n      providesTags: ['Post'],\n    }),\n    updatePost: build.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `post/${id}`,\n        method: 'PATCH',\n        body: patch,\n      }),\n      // highlight-start\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedPost } = await queryFulfilled\n          const patchResult = dispatch(\n            api.util.updateQueryData('getPost', id, (draft) => {\n              Object.assign(draft, updatedPost)\n            })\n          )\n        } catch {}\n      },\n      // highlight-end\n    }),\n  }),\n})\n")))),(0,r.kt)("h3",{id:"general-updates"},"General Updates"),(0,r.kt)("p",null,"If you find yourself wanting to update cache data elsewhere in your application, you can do so\nanywhere you have access to the ",(0,r.kt)("inlineCode",{parentName:"p"},"store.dispatch")," method, including within React components via\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://react-redux.js.org/api/hooks#usedispatch"},"useDispatch")," hook (or a typed version such\nas ",(0,r.kt)("a",{parentName:"p",href:"https://react-redux.js.org/using-react-redux/usage-with-typescript#define-typed-hooks"},"useAppDispatch"),"\nfor typescript users)."),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"You should generally avoid manually updating the cache outside of the ",(0,r.kt)("inlineCode",{parentName:"p"},"onQueryStarted"),"\ncallback for a mutation without a good reason, as RTK Query is intended to be used by considering\nyour cached data as a reflection of the server-side state."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="General manual cache update example"',title:'"General',manual:!0,cache:!0,update:!0,'example"':!0},"import { api } from './api'\nimport { useAppDispatch } from './store/hooks'\n\nfunction App() {\n  const dispatch = useAppDispatch()\n\n  function handleClick() {\n    /**\n     * This will update the cache data for the query corresponding to the `getPosts` endpoint,\n     * when that endpoint is used with no argument (undefined).\n     */\n    const patchCollection = dispatch(\n      api.util.updateQueryData('getPosts', undefined, (draftPosts) => {\n        draftPosts.push({ id: 1, name: 'Teddy' })\n      })\n    )\n  }\n\n  return <button onClick={handleClick}>Add post to cache</button>\n}\n")))}m.isMDXComponent=!0}}]);