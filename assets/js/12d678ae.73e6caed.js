"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9902],{4994:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return d},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return p}});var a=n(5773),r=n(808),i=(n(7378),n(5318)),c=n(517),o=n(7637),s=["components"],l={id:"createSlice",title:"createSlice",sidebar_label:"createSlice",hide_title:!0},d=void 0,u={unversionedId:"api/createSlice",id:"api/createSlice",isDocsHomePage:!1,title:"createSlice",description:"&nbsp;",source:"@site/../docs/api/createSlice.mdx",sourceDirName:"api",slug:"/api/createSlice",permalink:"/redux-toolkit/api/createSlice",tags:[],version:"current",lastUpdatedAt:1656209250,formattedLastUpdatedAt:"6/26/2022",frontMatter:{id:"createSlice",title:"createSlice",sidebar_label:"createSlice",hide_title:!0},sidebar:"docs",previous:{title:"createAction",permalink:"/redux-toolkit/api/createAction"},next:{title:"createAsyncThunk",permalink:"/redux-toolkit/api/createAsyncThunk"}},p=[{value:"Parameters",id:"parameters",children:[{value:"<code>initialState</code>",id:"initialstate",children:[],level:3},{value:"<code>name</code>",id:"name",children:[],level:3},{value:"<code>reducers</code>",id:"reducers",children:[{value:"Customizing Generated Action Creators",id:"customizing-generated-action-creators",children:[],level:4}],level:3},{value:"<code>extraReducers</code>",id:"extrareducers",children:[],level:3},{value:"The <code>extraReducers</code> &quot;builder callback&quot; notation",id:"the-extrareducers-builder-callback-notation",children:[],level:3},{value:"The <code>extraReducers</code> &quot;map object&quot; notation",id:"the-extrareducers-map-object-notation",children:[],level:3}],level:2},{value:"Return Value",id:"return-value",children:[],level:2},{value:"\uc608\uc2dc",id:"\uc608\uc2dc",children:[],level:2}],m={toc:p};function h(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"createslice"},(0,i.kt)("inlineCode",{parentName:"h1"},"createSlice")),(0,i.kt)("p",null,'\ucd08\uae30 state, reducer \ud568\uc218\uc758 \uac1d\uccb4, "slice \uc774\ub984"\uc744 \ubc1b\uc544 reducer \ubc0f state\uc5d0 \ud574\ub2f9\ud558\ub294 \uc561\uc158 \uc0dd\uc131\uc790\uc640 \uc561\uc158 \uc720\ud615\uc744 \uc790\ub3d9\uc73c\ub85c \uc0dd\uc131\ud558\ub294 \ud568\uc218\uc785\ub2c8\ub2e4.'),(0,i.kt)("p",null,"\uc774 API\ub294 Redux \ub85c\uc9c1\uc744 \uc791\uc131\ud558\uae30 \uc704\ud55c \ud45c\uc900 \uc811\uadfc \ubc29\uc2dd\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,"Internally, it uses ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createAction"},(0,i.kt)("inlineCode",{parentName:"a"},"createAction"))," and ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createReducer"},(0,i.kt)("inlineCode",{parentName:"a"},"createReducer")),", so\nyou may also use ",(0,i.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/"},"Immer"),' to write "mutating" immutable updates:'),(0,i.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst initialState = { value: 0 } as CounterState\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: {\n    increment(state) {\n      state.value++\n    },\n    decrement(state) {\n      state.value--\n    },\n    incrementByAmount(state, action: PayloadAction<number>) {\n      state.value += action.payload\n    },\n  },\n})\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\nexport default counterSlice.reducer\n"))),(0,i.kt)(c.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = { value: 0 }\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: {\n    increment(state) {\n      state.value++\n    },\n    decrement(state) {\n      state.value--\n    },\n    incrementByAmount(state, action) {\n      state.value += action.payload\n    },\n  },\n})\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\nexport default counterSlice.reducer\n")))),(0,i.kt)("h2",{id:"parameters"},"Parameters"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"createSlice"),"\ub294 \ub2e4\uc74c \uc635\uc158\uacfc \ud568\uaed8 \ub2e8\uc77c \uad6c\uc131 \uac1d\uccb4 \ub9e4\uac1c\ubcc0\uc218\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'function createSlice({\n    // A name, used in action types\n    name: string,\n    // The initial state for the reducer\n    initialState: any,\n    // An object of "case reducers". Key names will be used to generate actions.\n    reducers: Object<string, ReducerFunction | ReducerAndPrepareObject>\n    // A "builder callback" function used to add more reducers, or\n    // an additional object of "case reducers", where the keys should be other\n    // action types\n    extraReducers?:\n    | Object<string, ReducerFunction>\n    | ((builder: ActionReducerMapBuilder<State>) => void)\n})\n')),(0,i.kt)("h3",{id:"initialstate"},(0,i.kt)("inlineCode",{parentName:"h3"},"initialState")),(0,i.kt)("p",null,"\uc774 slice\uc758 \ucd08\uae30 state\uac12\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,'\uc774\uac83\uc740 \ud638\ucd9c\ub420 \ub54c \ucd08\uae30 state\uac12\uc744 \ubc18\ud658\ud574\uc57c\ud558\ub294 "lazy initializer" \ud568\uc218\uc77c \uc218\ub3c4 \uc788\uc2b5\ub2c8\ub2e4. This will be used whenever the reducer is called with ',(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," as its state value, and is primarily useful for cases like reading initial state from ",(0,i.kt)("inlineCode",{parentName:"p"},"localStorage"),"."),(0,i.kt)("h3",{id:"name"},(0,i.kt)("inlineCode",{parentName:"h3"},"name")),(0,i.kt)("p",null,"\uc774 slice of state\uc758 \ubb38\uc790\uc5f4 \uc774\ub984\uc785\ub2c8\ub2e4. Generated action type constants will use this as a prefix."),(0,i.kt)("h3",{id:"reducers"},(0,i.kt)("inlineCode",{parentName:"h3"},"reducers")),(0,i.kt)("p",null,'An object containing Redux "case reducer" functions (functions intended to handle a specific action type, equivalent\nto a single case statement in a switch).'),(0,i.kt)("p",null,"The keys in the object will be used to generate string action type constants, and these will show up in the Redux\nDevTools Extension when they are dispatched. Also, if any other part of the application happens to dispatch an action\nwith the exact same type string, the corresponding reducer will be run. Therefore, you should give the functions\ndescriptive names."),(0,i.kt)("p",null,"\uc774 \uac1d\uccb4\ub294 ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createReducer"},(0,i.kt)("inlineCode",{parentName:"a"},"createReducer")),'\ub85c \uc804\ub2ec\ub418\ubbc0\ub85c \uac10\uc18d\uae30\ub294 \uc8fc\uc5b4\uc9c4 state\ub97c \uc548\uc804\ud558\uac8c "mutate"\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.'),(0,i.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createSlice } from '@reduxjs/toolkit'\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {\n    increment: (state) => state + 1,\n  },\n})\n// Will handle the action type `'counter/increment'`\n"))),(0,i.kt)(c.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSlice } from '@reduxjs/toolkit'\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {\n    increment: (state) => state + 1,\n  },\n})\n// Will handle the action type `'counter/increment'`\n")))),(0,i.kt)("h4",{id:"customizing-generated-action-creators"},"Customizing Generated Action Creators"),(0,i.kt)("p",null,"If you need to customize the creation of the payload value of an action creator by means of a ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createAction#using-prepare-callbacks-to-customize-action-contents"},(0,i.kt)("inlineCode",{parentName:"a"},"prepare callback")),", the value of the appropriate field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"reducers")," argument object should be an object instead of a function. This object must contain two properties: ",(0,i.kt)("inlineCode",{parentName:"p"},"reducer")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"prepare"),". The value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"reducer")," field should be the case reducer function while the value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"prepare")," field should be the prepare callback function:"),(0,i.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createSlice, PayloadAction, nanoid } from '@reduxjs/toolkit'\n\ninterface Item {\n  id: string\n  text: string\n}\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [] as Item[],\n  reducers: {\n    addTodo: {\n      reducer: (state, action: PayloadAction<Item>) => {\n        state.push(action.payload)\n      },\n      prepare: (text: string) => {\n        const id = nanoid()\n        return { payload: { id, text } }\n      },\n    },\n  },\n})\n"))),(0,i.kt)(c.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSlice, nanoid } from '@reduxjs/toolkit'\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    addTodo: {\n      reducer: (state, action) => {\n        state.push(action.payload)\n      },\n      prepare: (text) => {\n        const id = nanoid()\n        return { payload: { id, text } }\n      },\n    },\n  },\n})\n")))),(0,i.kt)("h3",{id:"extrareducers"},(0,i.kt)("inlineCode",{parentName:"h3"},"extraReducers")),(0,i.kt)("p",null,'One of the key concepts of Redux is that each slice reducer "owns" its slice of state, and that many slice reducers\ncan independently respond to the same action type. ',(0,i.kt)("inlineCode",{parentName:"p"},"extraReducers")," \ub97c \uc0ac\uc6a9\ud558\uba74 ",(0,i.kt)("inlineCode",{parentName:"p"},"createSlice")," \uac00 \uc0dd\uc131\ud55c action types \uc678\uc758\n\ub2e4\ub978 action types\uc5d0\ub3c4 \uc751\ub2f5\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,i.kt)("p",null,"As case reducers specified with ",(0,i.kt)("inlineCode",{parentName:"p"},"extraReducers"),' are meant to reference "external" actions, they will not have actions generated in ',(0,i.kt)("inlineCode",{parentName:"p"},"slice.actions"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"reducers"),"\uc640 \ub9c8\ucc2c\uac00\uc9c0\ub85c, \uc774 case reducers \ub610\ud55c ",(0,i.kt)("inlineCode",{parentName:"p"},"createReducer"),'\ub97c \ud1b5\ud574 \uc804\ub2ec\ub418\uba70 state\ub97c \uc548\uc804\ud558\uac8c "mutate" \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.'),(0,i.kt)("p",null,"If two fields from ",(0,i.kt)("inlineCode",{parentName:"p"},"reducers")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"extraReducers")," happen to end up with the same action type string,\nthe function from ",(0,i.kt)("inlineCode",{parentName:"p"},"reducers")," will be used to handle that action type."),(0,i.kt)("h3",{id:"the-extrareducers-builder-callback-notation"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"extraReducers"),' "builder callback" notation'),(0,i.kt)("p",null,"'extraReducers'\ub97c \uc0ac\uc6a9\ud558\ub294 \uad8c\uc7a5 \ubc29\ubc95\uc740 'ActionReducerMapBuilder' \uc778\uc2a4\ud134\uc2a4\ub97c \uc218\uc2e0\ud558\ub294 \ucf5c\ubc31\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,"This builder notation is also the only way to add matcher reducers and default case reducers to your slice."),(0,i.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createAction, createSlice, Action, AnyAction } from '@reduxjs/toolkit'\nconst incrementBy = createAction<number>('incrementBy')\nconst decrement = createAction('decrement')\n\ninterface RejectedAction extends Action {\n  error: Error\n}\n\nfunction isRejectedAction(action: AnyAction): action is RejectedAction {\n  return action.type.endsWith('rejected')\n}\n\ncreateSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementBy, (state, action) => {\n        // action is inferred correctly here if using TS\n      })\n      // You can chain calls, or have separate `builder.addCase()` lines each time\n      .addCase(decrement, (state, action) => {})\n      // You can match a range of action types\n      .addMatcher(\n        isRejectedAction,\n        // `action` will be inferred as a RejectedAction due to isRejectedAction being defined as a type guard\n        (state, action) => {}\n      )\n      // and provide a default case if no other handlers matched\n      .addDefaultCase((state, action) => {})\n  },\n})\n"))),(0,i.kt)(c.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createAction, createSlice } from '@reduxjs/toolkit'\nconst incrementBy = createAction('incrementBy')\nconst decrement = createAction('decrement')\n\nfunction isRejectedAction(action) {\n  return action.type.endsWith('rejected')\n}\n\ncreateSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementBy, (state, action) => {\n        // action is inferred correctly here if using TS\n      })\n      // You can chain calls, or have separate `builder.addCase()` lines each time\n      .addCase(decrement, (state, action) => {})\n      // You can match a range of action types\n      .addMatcher(\n        isRejectedAction,\n        // `action` will be inferred as a RejectedAction due to isRejectedAction being defined as a type guard\n        (state, action) => {}\n      )\n      // and provide a default case if no other handlers matched\n      .addDefaultCase((state, action) => {})\n  },\n})\n")))),(0,i.kt)("p",null,"We recommend using this API as it has better TypeScript support (and thus, IDE autocomplete even for JavaScript users), as it will correctly infer the action type in the reducer based on the provided action creator.\nIt's particularly useful for working with actions produced by ",(0,i.kt)("inlineCode",{parentName:"p"},"createAction")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"createAsyncThunk"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createReducer#usage-with-the-builder-callback-notation"},'the "Builder Callback Notation" section of the ',(0,i.kt)("inlineCode",{parentName:"a"},"createReducer")," reference")," for details on how to use ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addCase"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addMatcher"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addDefault")),(0,i.kt)("h3",{id:"the-extrareducers-map-object-notation"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"extraReducers"),' "map object" notation'),(0,i.kt)("p",null,"Like ",(0,i.kt)("inlineCode",{parentName:"p"},"reducers"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"extraReducers")," can be an object containing Redux case reducer functions. However, the keys should\nbe other Redux string action type constants, and ",(0,i.kt)("inlineCode",{parentName:"p"},"createSlice")," will ",(0,i.kt)("em",{parentName:"p"},"not")," auto-generate action types or action creators\nfor reducers included in this parameter."),(0,i.kt)("p",null,"Action creators that were generated using ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createAction"},(0,i.kt)("inlineCode",{parentName:"a"},"createAction"))," may be used directly as the keys here, using\ncomputed property syntax."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const incrementBy = createAction('incrementBy')\n\ncreateSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {},\n  extraReducers: {\n    [incrementBy]: (state, action) => {\n      return state + action.payload\n    },\n    'some/other/action': (state, action) => {},\n  },\n})\n")),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"\uc6b0\ub9ac\ub294 'builder callback' API\ub97c \uae30\ubcf8\uc801\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \uac83\uc744 \uad8c\uc7a5\ud558\uba70, \ud2b9\ud788 Typescript\ub97c \uc0ac\uc6a9\ud55c\ub2e4\uba74 \ub354\uc6b1 \uad8c\uc7a5\ud569\ub2c8\ub2e4. \ub9cc\uc57d Typescript\ub97c \uc0ac\uc6a9\ud558\uba74\uc11c 'builder callback'\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\ub294\ub2e4\uba74, ",(0,i.kt)("inlineCode",{parentName:"p"},"actionCreator.type")," \ub098 ",(0,i.kt)("inlineCode",{parentName:"p"},"actionCreator.toString()")," \ub97c \ud1b5\ud574 TS compiler\uac00 \uacc4\uc0b0\ub41c property\ub97c \ubc1b\ub3c4\ub85d \ud574\uc57c\ud569\ub2c8\ub2e4. \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/usage/usage-with-typescript#type-safety-with-extraReducers"},"Usage With TypeScript")," \ub97c \ucc38\uc870\ud558\uc138\uc694."))),(0,i.kt)("h2",{id:"return-value"},"Return Value"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"createSlice"),"\ub294 \ub2e4\uc74c\uacfc \uac19\uc740 \uac1d\uccb4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"{\n    name : string,\n    reducer : ReducerFunction,\n    actions : Record<string, ActionCreator>,\n    caseReducers: Record<string, CaseReducer>.\n    getInitialState: () => State\n}\n")),(0,i.kt)("p",null,"Each function defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"reducers")," argument will have a corresponding action creator generated using ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createAction"},(0,i.kt)("inlineCode",{parentName:"a"},"createAction")),"\nand included in the result's ",(0,i.kt)("inlineCode",{parentName:"p"},"actions")," field using the same function name."),(0,i.kt)("p",null,"The generated ",(0,i.kt)("inlineCode",{parentName:"p"},"reducer")," function is suitable for passing to the Redux ",(0,i.kt)("inlineCode",{parentName:"p"},"combineReducers"),' function as a "slice reducer".'),(0,i.kt)("p",null,"You may want to consider destructuring the action creators and exporting them individually, for ease of searching\nfor references in a larger codebase."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note"),": the result object is conceptually similar to a\n",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/faq/code-structure#what-should-my-file-structure-look-like-how-should-i-group-my-action-creators-and-reducers-in-my-project-where-should-my-selectors-go"},'"Redux duck" code structure'),".\nThe actual code structure you use is up to you, but there are a couple caveats to keep in mind:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Actions are not exclusively limited to a single slice. Any part of the reducer logic can (and should!) respond\nto any dispatched action."),(0,i.kt)("li",{parentName:"ul"},"At the same time, circular references can cause import problems. If slices A and B are defined in\nseparate files, and each file tries to import the other so it can listen to other actions, unexpected\nbehavior may occur."))),(0,i.kt)("h2",{id:"\uc608\uc2dc"},"\uc608\uc2dc"),(0,i.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createSlice, createAction, PayloadAction } from '@reduxjs/toolkit'\nimport { createStore, combineReducers } from 'redux'\n\nconst incrementBy = createAction<number>('incrementBy')\nconst decrementBy = createAction<number>('decrementBy')\n\nconst counter = createSlice({\n  name: 'counter',\n  initialState: 0 as number,\n  reducers: {\n    increment: (state) => state + 1,\n    decrement: (state) => state - 1,\n    multiply: {\n      reducer: (state, action: PayloadAction<number>) => state * action.payload,\n      prepare: (value?: number) => ({ payload: value || 2 }), // fallback if the payload is a falsy value\n    },\n  },\n  // \"builder callback API\", TypeScript \uc0ac\uc6a9\uc790\uc5d0\uac8c \uad8c\uc7a5\ub429\ub2c8\ub2e4.\n  extraReducers: (builder) => {\n    builder.addCase(incrementBy, (state, action) => {\n      return state + action.payload\n    })\n    builder.addCase(decrementBy, (state, action) => {\n      return state - action.payload\n    })\n  },\n})\n\nconst user = createSlice({\n  name: 'user',\n  initialState: { name: '', age: 20 },\n  reducers: {\n    setUserName: (state, action) => {\n      state.name = action.payload // mutate the state all you want with immer\n    },\n  },\n  // \"map object API\"\n  extraReducers: {\n    // @ts-expect-error in TypeScript, this would need to be [counter.actions.increment.type]\n    [counter.actions.increment]: (\n      state,\n      action /* action will be inferred as \"any\", as the map notation does not contain type information */\n    ) => {\n      state.age += 1\n    },\n  },\n})\n\nconst reducer = combineReducers({\n  counter: counter.reducer,\n  user: user.reducer,\n})\n\nconst store = createStore(reducer)\n\nstore.dispatch(counter.actions.increment())\n// -> { counter: 1, user: {name : '', age: 21} }\nstore.dispatch(counter.actions.increment())\n// -> { counter: 2, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply(3))\n// -> { counter: 6, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply())\n// -> { counter: 12, user: {name: '', age: 22} }\nconsole.log(`${counter.actions.decrement}`)\n// -> \"counter/decrement\"\nstore.dispatch(user.actions.setUserName('eric'))\n// -> { counter: 12, user: { name: 'eric', age: 22} }\n"))),(0,i.kt)(c.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSlice, createAction } from '@reduxjs/toolkit'\nimport { createStore, combineReducers } from 'redux'\n\nconst incrementBy = createAction('incrementBy')\nconst decrementBy = createAction('decrementBy')\n\nconst counter = createSlice({\n  name: 'counter',\n  initialState: 0,\n  reducers: {\n    increment: (state) => state + 1,\n    decrement: (state) => state - 1,\n    multiply: {\n      reducer: (state, action) => state * action.payload,\n      prepare: (value) => ({ payload: value || 2 }), // fallback if the payload is a falsy value\n    },\n  },\n  // \"builder callback API\", TypeScript \uc0ac\uc6a9\uc790\uc5d0\uac8c \uad8c\uc7a5\ub429\ub2c8\ub2e4.\n  extraReducers: (builder) => {\n    builder.addCase(incrementBy, (state, action) => {\n      return state + action.payload\n    })\n    builder.addCase(decrementBy, (state, action) => {\n      return state - action.payload\n    })\n  },\n})\n\nconst user = createSlice({\n  name: 'user',\n  initialState: { name: '', age: 20 },\n  reducers: {\n    setUserName: (state, action) => {\n      state.name = action.payload // mutate the state all you want with immer\n    },\n  },\n  // \"map object API\"\n  extraReducers: {\n    [counter.actions.increment]: (\n      state,\n      action /* action will be inferred as \"any\", as the map notation does not contain type information */\n    ) => {\n      state.age += 1\n    },\n  },\n})\n\nconst reducer = combineReducers({\n  counter: counter.reducer,\n  user: user.reducer,\n})\n\nconst store = createStore(reducer)\n\nstore.dispatch(counter.actions.increment())\n// -> { counter: 1, user: {name : '', age: 21} }\nstore.dispatch(counter.actions.increment())\n// -> { counter: 2, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply(3))\n// -> { counter: 6, user: {name: '', age: 22} }\nstore.dispatch(counter.actions.multiply())\n// -> { counter: 12, user: {name: '', age: 22} }\nconsole.log(`${counter.actions.decrement}`)\n// -> \"counter/decrement\"\nstore.dispatch(user.actions.setUserName('eric'))\n// -> { counter: 12, user: { name: 'eric', age: 22} }\n")))))}h.isMDXComponent=!0}}]);