"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3633],{71:function(e,t,a){a.r(t),a.d(t,{contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return p}});var n=a(5773),r=a(808),i=(a(7378),a(5318)),o=a(517),c=a(7637),d=["components"],l={id:"createReducer",title:"createReducer",sidebar_label:"createReducer",hide_title:!0},s=void 0,u={unversionedId:"api/createReducer",id:"api/createReducer",isDocsHomePage:!1,title:"createReducer",description:"&nbsp;",source:"@site/../docs/api/createReducer.mdx",sourceDirName:"api",slug:"/api/createReducer",permalink:"/redux-toolkit/api/createReducer",tags:[],version:"current",lastUpdatedAt:1656217065,formattedLastUpdatedAt:"6/26/2022",frontMatter:{id:"createReducer",title:"createReducer",sidebar_label:"createReducer",hide_title:!0},sidebar:"docs",previous:{title:"createListenerMiddleware",permalink:"/redux-toolkit/api/createListenerMiddleware"},next:{title:"createAction",permalink:"/redux-toolkit/api/createAction"}},p=[{value:"Overview",id:"overview",children:[],level:2},{value:"Usage with the &quot;Builder Callback&quot; Notation",id:"usage-with-the-builder-callback-notation",children:[{value:"Parameters",id:"parameters",children:[],level:3},{value:"Example Usage",id:"example-usage",children:[],level:3},{value:"Builder Methods",id:"builder-methods",children:[],level:3},{value:"<code>builder.addCase</code>",id:"builderaddcase",children:[{value:"Parameters",id:"parameters-1",children:[],level:4}],level:3},{value:"<code>builder.addMatcher</code>",id:"builderaddmatcher",children:[{value:"Parameters",id:"parameters-2",children:[],level:4}],level:3},{value:"<code>builder.addDefaultCase</code>",id:"builderadddefaultcase",children:[{value:"Parameters",id:"parameters-3",children:[],level:4}],level:3}],level:2},{value:"Usage with the &quot;Map Object&quot; Notation",id:"usage-with-the-map-object-notation",children:[{value:"Parameters",id:"parameters-4",children:[],level:3},{value:"Returns",id:"returns",children:[],level:3},{value:"Example Usage",id:"example-usage-1",children:[],level:3},{value:"Matchers and Default Cases as Arguments",id:"matchers-and-default-cases-as-arguments",children:[],level:3}],level:2},{value:"Direct State Mutation",id:"direct-state-mutation",children:[],level:2},{value:"Multiple Case Reducer Execution",id:"multiple-case-reducer-execution",children:[],level:2},{value:"Logging Draft State Values",id:"logging-draft-state-values",children:[],level:2}],m={toc:p};function h(e){var t=e.components,a=(0,r.Z)(e,d);return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"createreducer"},(0,i.kt)("inlineCode",{parentName:"h1"},"createReducer()")),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,'A utility that simplifies creating Redux reducer functions. It uses Immer internally to drastically simplify immutable update logic\nby writing "mutative" code in your reducers, and supports directly mapping specific action types to case reducer functions\nthat will update the state when that action is dispatched.'),(0,i.kt)("p",null,"Redux ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/basics/reducers"},"reducers")," are often implemented using a ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," statement, with one ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," for every handled action type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const initialState = { value: 0 }\n\nfunction counterReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'increment':\n      return { ...state, value: state.value + 1 }\n    case 'decrement':\n      return { ...state, value: state.value - 1 }\n    case 'incrementByAmount':\n      return { ...state, value: state.value + action.payload }\n    default:\n      return state\n  }\n}\n")),(0,i.kt)("p",null,"This approach works well, but is a bit boilerplate-y and error-prone. For instance, it is easy to forget the ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," case or\nsetting the initial state."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"createReducer"),' helper streamlines the implementation of such reducers. It supports two different forms of defining case\nreducers to handle actions: a "builder callback" notation and a "map object" notation. Both are equivalent, but the "builder callback"\nnotation is preferred.'),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"createReducer"),", your reducers instead look like:"),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\ninterface CounterState {\n  value: number\n}\n\nconst increment = createAction('counter/increment')\nconst decrement = createAction('counter/decrement')\nconst incrementByAmount = createAction<number>('counter/incrementByAmount')\n\nconst initialState = { value: 0 } as CounterState\n\nconst counterReducer = createReducer(initialState, (builder) => {\n  builder\n    .addCase(increment, (state, action) => {\n      state.value++\n    })\n    .addCase(decrement, (state, action) => {\n      state.value--\n    })\n    .addCase(incrementByAmount, (state, action) => {\n      state.value += action.payload\n    })\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\nconst increment = createAction('counter/increment')\nconst decrement = createAction('counter/decrement')\nconst incrementByAmount = createAction('counter/incrementByAmount')\n\nconst initialState = { value: 0 }\n\nconst counterReducer = createReducer(initialState, (builder) => {\n  builder\n    .addCase(increment, (state, action) => {\n      state.value++\n    })\n    .addCase(decrement, (state, action) => {\n      state.value--\n    })\n    .addCase(incrementByAmount, (state, action) => {\n      state.value += action.payload\n    })\n})\n")))),(0,i.kt)("h2",{id:"usage-with-the-builder-callback-notation"},'Usage with the "Builder Callback" Notation'),(0,i.kt)("p",null,"This overload accepts a callback function that receives a ",(0,i.kt)("inlineCode",{parentName:"p"},"builder")," object as its argument.\nThat builder provides ",(0,i.kt)("inlineCode",{parentName:"p"},"addCase"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"addMatcher")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"addDefaultCase")," functions that may be\ncalled to define what actions this reducer will handle."),(0,i.kt)("p",null,"The recommended way of using ",(0,i.kt)("inlineCode",{parentName:"p"},"createReducer")," is the builder callback notation, as it works best with TypeScript and most IDEs."),(0,i.kt)("h3",{id:"parameters"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"initialState")," ",(0,i.kt)("inlineCode",{parentName:"li"},"State | (() => State)"),': The initial state that should be used when the reducer is called the first time. This may also be a "lazy initializer" function, which should return an initial state value when called. This will be used whenever the reducer is called with ',(0,i.kt)("inlineCode",{parentName:"li"},"undefined")," as its state value, and is primarily useful for cases like reading initial state from ",(0,i.kt)("inlineCode",{parentName:"li"},"localStorage"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"builderCallback")," ",(0,i.kt)("inlineCode",{parentName:"li"},"(builder: Builder) => void")," A callback that receives a ",(0,i.kt)("em",{parentName:"li"},"builder")," object to define\ncase reducers via calls to ",(0,i.kt)("inlineCode",{parentName:"li"},"builder.addCase(actionCreatorOrType, reducer)"),".")),(0,i.kt)("h3",{id:"example-usage"},"Example Usage"),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n  createAction,\n  createReducer,\n  AnyAction,\n  PayloadAction,\n} from '@reduxjs/toolkit'\n\nconst increment = createAction<number>('increment')\nconst decrement = createAction<number>('decrement')\n\nfunction isActionWithNumberPayload(\n  action: AnyAction\n): action is PayloadAction<number> {\n  return typeof action.payload === 'number'\n}\n\nconst reducer = createReducer(\n  {\n    counter: 0,\n    sumOfNumberPayloads: 0,\n    unhandledActions: 0,\n  },\n  (builder) => {\n    builder\n      .addCase(increment, (state, action) => {\n        // action is inferred correctly here\n        state.counter += action.payload\n      })\n      // You can chain calls, or have separate `builder.addCase()` lines each time\n      .addCase(decrement, (state, action) => {\n        state.counter -= action.payload\n      })\n      // You can apply a \"matcher function\" to incoming actions\n      .addMatcher(isActionWithNumberPayload, (state, action) => {})\n      // and provide a default case if no other handlers matched\n      .addDefaultCase((state, action) => {})\n  }\n)\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\nconst increment = createAction('increment')\nconst decrement = createAction('decrement')\n\nfunction isActionWithNumberPayload(action) {\n  return typeof action.payload === 'number'\n}\n\nconst reducer = createReducer(\n  {\n    counter: 0,\n    sumOfNumberPayloads: 0,\n    unhandledActions: 0,\n  },\n  (builder) => {\n    builder\n      .addCase(increment, (state, action) => {\n        // action is inferred correctly here\n        state.counter += action.payload\n      })\n      // You can chain calls, or have separate `builder.addCase()` lines each time\n      .addCase(decrement, (state, action) => {\n        state.counter -= action.payload\n      })\n      // You can apply a \"matcher function\" to incoming actions\n      .addMatcher(isActionWithNumberPayload, (state, action) => {})\n      // and provide a default case if no other handlers matched\n      .addDefaultCase((state, action) => {})\n  }\n)\n")))),(0,i.kt)("h3",{id:"builder-methods"},"Builder Methods"),(0,i.kt)("h3",{id:"builderaddcase"},(0,i.kt)("inlineCode",{parentName:"h3"},"builder.addCase")),(0,i.kt)("p",null,"Adds a case reducer to handle a single exact action type."),(0,i.kt)("p",null,"All calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addCase")," must come before any calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addMatcher")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addDefaultCase"),"."),(0,i.kt)("h4",{id:"parameters-1"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"actionCreator")," Either a plain action type string, or an action creator generated by ",(0,i.kt)("a",{parentName:"li",href:"./createAction"},(0,i.kt)("inlineCode",{parentName:"a"},"createAction"))," that can be used to determine the action type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"reducer")," The actual case reducer function.")),(0,i.kt)("h3",{id:"builderaddmatcher"},(0,i.kt)("inlineCode",{parentName:"h3"},"builder.addMatcher")),(0,i.kt)("p",null,"Allows you to match your incoming actions against your own filter function instead of only the ",(0,i.kt)("inlineCode",{parentName:"p"},"action.type")," property."),(0,i.kt)("p",null,"If multiple matcher reducers match, all of them will be executed in the order\nthey were defined in - even if a case reducer already matched.\nAll calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addMatcher")," must come after any calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addCase")," and before any calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addDefaultCase"),"."),(0,i.kt)("h4",{id:"parameters-2"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"matcher")," A matcher function. In TypeScript, this should be a ",(0,i.kt)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates"},"type predicate"),"\nfunction"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"reducer")," The actual case reducer function.")),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n  createAction,\n  createReducer,\n  AsyncThunk,\n  AnyAction,\n} from '@reduxjs/toolkit'\n\ntype GenericAsyncThunk = AsyncThunk<unknown, unknown, any>\n\ntype PendingAction = ReturnType<GenericAsyncThunk['pending']>\ntype RejectedAction = ReturnType<GenericAsyncThunk['rejected']>\ntype FulfilledAction = ReturnType<GenericAsyncThunk['fulfilled']>\n\nconst initialState: Record<string, string> = {}\nconst resetAction = createAction('reset-tracked-loading-state')\n\nfunction isPendingAction(action: AnyAction): action is PendingAction {\n  return action.type.endsWith('/pending')\n}\n\nconst reducer = createReducer(initialState, (builder) => {\n  builder\n    .addCase(resetAction, () => initialState)\n    // matcher can be defined outside as a type predicate function\n    .addMatcher(isPendingAction, (state, action) => {\n      state[action.meta.requestId] = 'pending'\n    })\n    .addMatcher(\n      // matcher can be defined inline as a type predicate function\n      (action): action is RejectedAction => action.type.endsWith('/rejected'),\n      (state, action) => {\n        state[action.meta.requestId] = 'rejected'\n      }\n    )\n    // matcher can just return boolean and the matcher can receive a generic argument\n    .addMatcher<FulfilledAction>(\n      (action) => action.type.endsWith('/fulfilled'),\n      (state, action) => {\n        state[action.meta.requestId] = 'fulfilled'\n      }\n    )\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\nconst initialState = {}\nconst resetAction = createAction('reset-tracked-loading-state')\n\nfunction isPendingAction(action) {\n  return action.type.endsWith('/pending')\n}\n\nconst reducer = createReducer(initialState, (builder) => {\n  builder\n    .addCase(resetAction, () => initialState)\n    // matcher can be defined outside as a type predicate function\n    .addMatcher(isPendingAction, (state, action) => {\n      state[action.meta.requestId] = 'pending'\n    })\n    .addMatcher(\n      // matcher can be defined inline as a type predicate function\n      (action) => action.type.endsWith('/rejected'),\n      (state, action) => {\n        state[action.meta.requestId] = 'rejected'\n      }\n    )\n    // matcher can just return boolean and the matcher can receive a generic argument\n    .addMatcher(\n      (action) => action.type.endsWith('/fulfilled'),\n      (state, action) => {\n        state[action.meta.requestId] = 'fulfilled'\n      }\n    )\n})\n")))),(0,i.kt)("h3",{id:"builderadddefaultcase"},(0,i.kt)("inlineCode",{parentName:"h3"},"builder.addDefaultCase")),(0,i.kt)("p",null,'Adds a "default case" reducer that is executed if no case reducer and no matcher\nreducer was executed for this action.'),(0,i.kt)("h4",{id:"parameters-3"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"reducer"),' The fallback "default case" reducer function.')),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createReducer } from '@reduxjs/toolkit'\nconst initialState = { otherActions: 0 }\nconst reducer = createReducer(initialState, (builder) => {\n  builder\n    // .addCase(...)\n    // .addMatcher(...)\n    .addDefaultCase((state, action) => {\n      state.otherActions++\n    })\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createReducer } from '@reduxjs/toolkit'\nconst initialState = { otherActions: 0 }\nconst reducer = createReducer(initialState, (builder) => {\n  builder\n    // .addCase(...)\n    // .addMatcher(...)\n    .addDefaultCase((state, action) => {\n      state.otherActions++\n    })\n})\n")))),(0,i.kt)("h2",{id:"usage-with-the-map-object-notation"},'Usage with the "Map Object" Notation'),(0,i.kt)("p",null,"This overload accepts an object where the keys are string action types, and the values\nare case reducer functions to handle those action types."),(0,i.kt)("p",null,'While this notation is a bit shorter, it works only in JavaScript, not TypeScript and has less integration with IDEs,\nso we recommend the "builder callback" notation in most cases.'),(0,i.kt)("h3",{id:"parameters-4"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"initialState")," ",(0,i.kt)("inlineCode",{parentName:"li"},"State | (() => State)"),': The initial state that should be used when the reducer is called the first time. This may also be a "lazy initializer" function, which should return an initial state value when called. This will be used whenever the reducer is called with ',(0,i.kt)("inlineCode",{parentName:"li"},"undefined")," as its state value, and is primarily useful for cases like reading initial state from ",(0,i.kt)("inlineCode",{parentName:"li"},"localStorage"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"actionsMap")," An object mapping from action types to ",(0,i.kt)("em",{parentName:"li"},"case reducers"),", each of which handles one specific action type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"actionMatchers")," An array of matcher definitions in the form ",(0,i.kt)("inlineCode",{parentName:"li"},"{matcher, reducer}"),".\nAll matching reducers will be executed in order, independently if a case reducer matched or not."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"defaultCaseReducer"),' A "default case" reducer that is executed if no case reducer and no matcher\nreducer was executed for this action.')),(0,i.kt)("h3",{id:"returns"},"Returns"),(0,i.kt)("p",null,"The generated reducer function."),(0,i.kt)("p",null,"The reducer will have a ",(0,i.kt)("inlineCode",{parentName:"p"},"getInitialState")," function attached that will return the initial state when called. This may be useful for tests or usage with React's ",(0,i.kt)("inlineCode",{parentName:"p"},"useReducer")," hook:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const counterReducer = createReducer(0, {\n  increment: (state, action) => state + action.payload,\n  decrement: (state, action) => state - action.payload,\n})\n\nconsole.log(counterReducer.getInitialState()) // 0\n")),(0,i.kt)("h3",{id:"example-usage-1"},"Example Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const counterReducer = createReducer(0, {\n  increment: (state, action) => state + action.payload,\n  decrement: (state, action) => state - action.payload\n})\n\n// Alternately, use a "lazy initializer" to provide the initial state\n// (works with either form of createReducer)\nconst initialState = () => 0\nconst counterReducer = createReducer(initialState, {\n  increment: (state, action) => state + action.payload,\n  decrement: (state, action) => state - action.payload\n})\n')),(0,i.kt)("p",null,"Action creators that were generated using ",(0,i.kt)("a",{parentName:"p",href:"./createAction"},(0,i.kt)("inlineCode",{parentName:"a"},"createAction"))," may be used directly as the keys here, using computed property syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const increment = createAction('increment')\nconst decrement = createAction('decrement')\n\nconst counterReducer = createReducer(0, {\n  [increment]: (state, action) => state + action.payload,\n  [decrement.type]: (state, action) => state - action.payload\n})\n")),(0,i.kt)("h3",{id:"matchers-and-default-cases-as-arguments"},"Matchers and Default Cases as Arguments"),(0,i.kt)("p",null,"The most readable approach to define matcher cases and default cases is by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addMatcher")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.addDefaultCase")," methods described above, but it is also possible to use these with the object notation by passing an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"{matcher, reducer}")," objects as the third argument, and a default case reducer as the fourth argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const isStringPayloadAction = (action) => typeof action.payload === 'string'\n\nconst lengthOfAllStringsReducer = createReducer(\n  // initial state\n  { strLen: 0, nonStringActions: 0 },\n  // normal reducers\n  {\n    /*...*/\n  },\n  //  array of matcher reducers\n  [\n    {\n      matcher: isStringPayloadAction,\n      reducer(state, action) {\n        state.strLen += action.payload.length\n      },\n    },\n  ],\n  // default reducer\n  (state) => {\n    state.nonStringActions++\n  }\n)\n")),(0,i.kt)("h2",{id:"direct-state-mutation"},"Direct State Mutation"),(0,i.kt)("p",null,"Redux requires reducer functions to be pure and treat state values as immutable. While this is essential for making state updates predictable and observable, it can sometimes make the implementation of such updates awkward. Consider the following example:"),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\ninterface Todo {\n  text: string\n  completed: boolean\n}\n\nconst addTodo = createAction<Todo>('todos/add')\nconst toggleTodo = createAction<number>('todos/toggle')\n\nconst todosReducer = createReducer([] as Todo[], (builder) => {\n  builder\n    .addCase(addTodo, (state, action) => {\n      const todo = action.payload\n      return [...state, todo]\n    })\n    .addCase(toggleTodo, (state, action) => {\n      const index = action.payload\n      const todo = state[index]\n      return [\n        ...state.slice(0, index),\n        { ...todo, completed: !todo.completed },\n        ...state.slice(index + 1),\n      ]\n    })\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\nconst addTodo = createAction('todos/add')\nconst toggleTodo = createAction('todos/toggle')\n\nconst todosReducer = createReducer([], (builder) => {\n  builder\n    .addCase(addTodo, (state, action) => {\n      const todo = action.payload\n      return [...state, todo]\n    })\n    .addCase(toggleTodo, (state, action) => {\n      const index = action.payload\n      const todo = state[index]\n      return [\n        ...state.slice(0, index),\n        { ...todo, completed: !todo.completed },\n        ...state.slice(index + 1),\n      ]\n    })\n})\n")))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"addTodo")," reducer is straightforward if you know the ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"},"ES6 spread syntax"),". However, the code for ",(0,i.kt)("inlineCode",{parentName:"p"},"toggleTodo")," is much less straightforward, especially considering that it only sets a single flag."),(0,i.kt)("p",null,"To make things easier, ",(0,i.kt)("inlineCode",{parentName:"p"},"createReducer")," uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mweststrate/immer"},"immer")," to let you write reducers as if they were mutating the state directly. In reality, the reducer receives a proxy state that translates all mutations into equivalent copy operations."),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\ninterface Todo {\n  text: string\n  completed: boolean\n}\n\nconst addTodo = createAction<Todo>('todos/add')\nconst toggleTodo = createAction<number>('todos/toggle')\n\nconst todosReducer = createReducer([] as Todo[], (builder) => {\n  builder\n    .addCase(addTodo, (state, action) => {\n      // This push() operation gets translated into the same\n      // extended-array creation as in the previous example.\n      const todo = action.payload\n      state.push(todo)\n    })\n    .addCase(toggleTodo, (state, action) => {\n      // The \"mutating\" version of this case reducer is much\n      //  more direct than the explicitly pure one.\n      const index = action.payload\n      const todo = state[index]\n      todo.completed = !todo.completed\n    })\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\nconst addTodo = createAction('todos/add')\nconst toggleTodo = createAction('todos/toggle')\n\nconst todosReducer = createReducer([], (builder) => {\n  builder\n    .addCase(addTodo, (state, action) => {\n      // This push() operation gets translated into the same\n      // extended-array creation as in the previous example.\n      const todo = action.payload\n      state.push(todo)\n    })\n    .addCase(toggleTodo, (state, action) => {\n      // The \"mutating\" version of this case reducer is much\n      //  more direct than the explicitly pure one.\n      const index = action.payload\n      const todo = state[index]\n      todo.completed = !todo.completed\n    })\n})\n")))),(0,i.kt)("p",null,'Writing "mutating" reducers simplifies the code. It\'s shorter, there\'s less indirection, and it eliminates common mistakes made while spreading nested state. However, the use of Immer does add some "magic", and Immer has its own nuances in behavior. You should read through ',(0,i.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/pitfalls"},"pitfalls mentioned in the immer docs")," . Most importantly, ",(0,i.kt)("strong",{parentName:"p"},"you need to ensure that you either mutate the ",(0,i.kt)("inlineCode",{parentName:"strong"},"state")," argument or return a new state, ",(0,i.kt)("em",{parentName:"strong"},"but not both")),". For example, the following reducer would throw an exception if a ",(0,i.kt)("inlineCode",{parentName:"p"},"toggleTodo")," action is passed:"),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\ninterface Todo {\n  text: string\n  completed: boolean\n}\n\nconst toggleTodo = createAction<number>('todos/toggle')\n\nconst todosReducer = createReducer([] as Todo[], (builder) => {\n  builder.addCase(toggleTodo, (state, action) => {\n    const index = action.payload\n    const todo = state[index]\n\n    // This case reducer both mutates the passed-in state...\n    todo.completed = !todo.completed\n\n    // ... and returns a new value. This will throw an\n    // exception. In this example, the easiest fix is\n    // to remove the `return` statement.\n    return [...state.slice(0, index), todo, ...state.slice(index + 1)]\n  })\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createAction, createReducer } from '@reduxjs/toolkit'\n\nconst toggleTodo = createAction('todos/toggle')\n\nconst todosReducer = createReducer([], (builder) => {\n  builder.addCase(toggleTodo, (state, action) => {\n    const index = action.payload\n    const todo = state[index]\n\n    // This case reducer both mutates the passed-in state...\n    todo.completed = !todo.completed\n\n    // ... and returns a new value. This will throw an\n    // exception. In this example, the easiest fix is\n    // to remove the `return` statement.\n    return [...state.slice(0, index), todo, ...state.slice(index + 1)]\n  })\n})\n")))),(0,i.kt)("h2",{id:"multiple-case-reducer-execution"},"Multiple Case Reducer Execution"),(0,i.kt)("p",null,"Originally, ",(0,i.kt)("inlineCode",{parentName:"p"},"createReducer")," always matched a given action type to a single case reducer, and only that one case reducer would execute for a given action."),(0,i.kt)("p",null,"Using action matchers changes that behavior, as multiple matchers may handle a single action."),(0,i.kt)("p",null,"For any dispatched action, the behavior is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If there is an exact match for the action type, the corresponding case reducer will execute first"),(0,i.kt)("li",{parentName:"ul"},"Any matchers that return ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," will execute in the order they were defined"),(0,i.kt)("li",{parentName:"ul"},"If a default case reducer is provided, and ",(0,i.kt)("em",{parentName:"li"},"no")," case or matcher reducers ran, the default case reducer will execute"),(0,i.kt)("li",{parentName:"ul"},"If no case or matcher reducers ran, the original existing state value will be returned unchanged")),(0,i.kt)("p",null,"The executing reducers form a pipeline, and each of them will receive the output of the previous reducer:"),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createReducer } from '@reduxjs/toolkit'\n\nconst reducer = createReducer(0, (builder) => {\n  builder\n    .addCase('increment', (state) => state + 1)\n    .addMatcher(\n      (action) => action.type.startsWith('i'),\n      (state) => state * 5\n    )\n    .addMatcher(\n      (action) => action.type.endsWith('t'),\n      (state) => state + 2\n    )\n})\n\nconsole.log(reducer(0, { type: 'increment' }))\n// Returns 7, as the 'increment' case and both matchers all ran in sequence:\n// - case 'increment\": 0 => 1\n// - matcher starts with 'i': 1 => 5\n// - matcher ends with 't': 5 => 7\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createReducer } from '@reduxjs/toolkit'\n\nconst reducer = createReducer(0, (builder) => {\n  builder\n    .addCase('increment', (state) => state + 1)\n    .addMatcher(\n      (action) => action.type.startsWith('i'),\n      (state) => state * 5\n    )\n    .addMatcher(\n      (action) => action.type.endsWith('t'),\n      (state) => state + 2\n    )\n})\n\nconsole.log(reducer(0, { type: 'increment' }))\n// Returns 7, as the 'increment' case and both matchers all ran in sequence:\n// - case 'increment\": 0 => 1\n// - matcher starts with 'i': 1 => 5\n// - matcher ends with 't': 5 => 7\n")))),(0,i.kt)("h2",{id:"logging-draft-state-values"},"Logging Draft State Values"),(0,i.kt)("p",null,"It's very common for a developer to call ",(0,i.kt)("inlineCode",{parentName:"p"},"console.log(state)")," during the development process. However, browsers display Proxies in a format that is hard to read, which can make console logging of Immer-based state difficult."),(0,i.kt)("p",null,"When using either ",(0,i.kt)("inlineCode",{parentName:"p"},"createSlice")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"createReducer"),", you may use the ",(0,i.kt)("a",{parentName:"p",href:"/redux-toolkit/api/other-exports#current"},(0,i.kt)("inlineCode",{parentName:"a"},"current"))," utility that we re-export from the ",(0,i.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/current"},(0,i.kt)("inlineCode",{parentName:"a"},"immer")," library"),". This utility creates a separate plain copy of the current Immer ",(0,i.kt)("inlineCode",{parentName:"p"},"Draft")," state value, which can then be logged for viewing as normal."),(0,i.kt)(c.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { createSlice, current } from '@reduxjs/toolkit'\n\nconst slice = createSlice({\n  name: 'todos',\n  initialState: [{ id: 1, title: 'Example todo' }],\n  reducers: {\n    addTodo: (state, action) => {\n      console.log('before', current(state))\n      state.push(action.payload)\n      console.log('after', current(state))\n    },\n  },\n})\n"))),(0,i.kt)(o.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSlice, current } from '@reduxjs/toolkit'\n\nconst slice = createSlice({\n  name: 'todos',\n  initialState: [{ id: 1, title: 'Example todo' }],\n  reducers: {\n    addTodo: (state, action) => {\n      console.log('before', current(state))\n      state.push(action.payload)\n      console.log('after', current(state))\n    },\n  },\n})\n")))))}h.isMDXComponent=!0}}]);