"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[891],{1800:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return p},default:function(){return c},frontMatter:function(){return u},metadata:function(){return d},toc:function(){return m}});var a=n(5773),r=n(808),s=(n(7378),n(5318)),i=n(517),o=n(7637),l=["components"],u={id:"customizing-queries",title:"Customizing Queries",sidebar_label:"Customizing Queries",hide_title:!0,description:"RTK Query > Usage > Customizing Queries: overriding default query behavior"},p=void 0,d={unversionedId:"rtk-query/usage/customizing-queries",id:"rtk-query/usage/customizing-queries",isDocsHomePage:!1,title:"Customizing Queries",description:"RTK Query > Usage > Customizing Queries: overriding default query behavior",source:"@site/../docs/rtk-query/usage/customizing-queries.mdx",sourceDirName:"rtk-query/usage",slug:"/rtk-query/usage/customizing-queries",permalink:"/redux-toolkit/rtk-query/usage/customizing-queries",tags:[],version:"current",lastUpdatedAt:1656210075,formattedLastUpdatedAt:"6/26/2022",frontMatter:{id:"customizing-queries",title:"Customizing Queries",sidebar_label:"Customizing Queries",hide_title:!0,description:"RTK Query > Usage > Customizing Queries: overriding default query behavior"},sidebar:"docs",previous:{title:"Customizing createApi",permalink:"/redux-toolkit/rtk-query/usage/customizing-create-api"},next:{title:"Usage Without React Hooks",permalink:"/redux-toolkit/rtk-query/usage/usage-without-react-hooks"}},m=[{value:"Customizing queries with <code>baseQuery</code>",id:"customizing-queries-with-basequery",children:[{value:"Implementing a custom <code>baseQuery</code>",id:"implementing-a-custom-basequery",children:[{value:"baseQuery function arguments",id:"basequery-function-arguments",children:[],level:4},{value:"baseQuery function return value",id:"basequery-function-return-value",children:[],level:4},{value:"fetchBaseQuery defaults",id:"fetchbasequery-defaults",children:[],level:4}],level:3}],level:2},{value:"Customizing query responses with <code>transformResponse</code>",id:"customizing-query-responses-with-transformresponse",children:[],level:2},{value:"Customizing queries with <code>queryFn</code>",id:"customizing-queries-with-queryfn",children:[{value:"Implementing a <code>queryFn</code>",id:"implementing-a-queryfn",children:[{value:"queryFn function arguments",id:"queryfn-function-arguments",children:[],level:4},{value:"queryFn function return value",id:"queryfn-function-return-value",children:[],level:4}],level:3}],level:2},{value:"Examples - <code>baseQuery</code>",id:"examples---basequery",children:[{value:"Axios baseQuery",id:"axios-basequery",children:[],level:3},{value:"GraphQL baseQuery",id:"graphql-basequery",children:[],level:3},{value:"Automatic re-authorization by extending fetchBaseQuery",id:"automatic-re-authorization-by-extending-fetchbasequery",children:[{value:"Preventing multiple unauthorized errors",id:"preventing-multiple-unauthorized-errors",children:[],level:4}],level:3},{value:"Automatic retries",id:"automatic-retries",children:[{value:"Bailing out of error re-tries",id:"bailing-out-of-error-re-tries",children:[],level:4}],level:3},{value:"Adding Meta information to queries",id:"adding-meta-information-to-queries",children:[],level:3},{value:"Constructing a Dynamic Base URL using Redux state",id:"constructing-a-dynamic-base-url-using-redux-state",children:[],level:3}],level:2},{value:"Examples - <code>transformResponse</code>",id:"examples---transformresponse",children:[{value:"Unpacking deeply nested GraphQL data",id:"unpacking-deeply-nested-graphql-data",children:[],level:3},{value:"Normalizing data with <code>createEntityAdapter</code>",id:"normalizing-data-with-createentityadapter",children:[],level:3}],level:2},{value:"Examples - <code>queryFn</code>",id:"examples---queryfn",children:[{value:"Using a no-op queryFn",id:"using-a-no-op-queryfn",children:[],level:3},{value:"Streaming data with no initial request",id:"streaming-data-with-no-initial-request",children:[],level:3},{value:"Performing multiple requests with a single query",id:"performing-multiple-requests-with-a-single-query",children:[],level:3}],level:2}],h={toc:m};function c(e){var t=e.components,n=(0,r.Z)(e,l);return(0,s.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"customizing-queries"},"Customizing queries"),(0,s.kt)("p",null,"RTK Query is agnostic as to how your requests resolve. You can use any library you like to handle requests, or no library at all. RTK Query provides reasonable defaults expected to cover the majority of use cases, while also allowing room for customization to alter query handling to fit specific needs."),(0,s.kt)("h2",{id:"customizing-queries-with-basequery"},"Customizing queries with ",(0,s.kt)("inlineCode",{parentName:"h2"},"baseQuery")),(0,s.kt)("p",null,"The default method to handle queries is via the ",(0,s.kt)("a",{parentName:"p",href:"../api/createApi#basequery"},(0,s.kt)("inlineCode",{parentName:"a"},"baseQuery"))," option on ",(0,s.kt)("a",{parentName:"p",href:"../api/createApi"},(0,s.kt)("inlineCode",{parentName:"a"},"createApi")),", in combination with the ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#query"},(0,s.kt)("inlineCode",{parentName:"a"},"query"))," option on an endpoint definition."),(0,s.kt)("p",null,"To process queries, endpoints are defined with a ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#query"},(0,s.kt)("inlineCode",{parentName:"a"},"query"))," option, which passes its return value to a common ",(0,s.kt)("a",{parentName:"p",href:"../api/createApi#basequery"},(0,s.kt)("inlineCode",{parentName:"a"},"baseQuery"))," function used for the API."),(0,s.kt)("p",null,"By default, RTK Query ships with ",(0,s.kt)("a",{parentName:"p",href:"../api/fetchBaseQuery"},(0,s.kt)("inlineCode",{parentName:"a"},"fetchBaseQuery")),", which is a lightweight ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"},(0,s.kt)("inlineCode",{parentName:"a"},"fetch"))," wrapper that automatically handles request headers and response parsing in a manner similar to common libraries like ",(0,s.kt)("inlineCode",{parentName:"p"},"axios"),". If ",(0,s.kt)("inlineCode",{parentName:"p"},"fetchBaseQuery")," alone does not meet your needs, you can customize its behaviour with a wrapper function, or create your own ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#basequery"},(0,s.kt)("inlineCode",{parentName:"a"},"baseQuery"))," function from scratch for ",(0,s.kt)("a",{parentName:"p",href:"../api/createApi"},(0,s.kt)("inlineCode",{parentName:"a"},"createApi"))," to use."),(0,s.kt)("p",null,"See also ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#basequery"},(0,s.kt)("inlineCode",{parentName:"a"},"baseQuery API Reference")),"."),(0,s.kt)("h3",{id:"implementing-a-custom-basequery"},"Implementing a custom ",(0,s.kt)("inlineCode",{parentName:"h3"},"baseQuery")),(0,s.kt)("p",null,"RTK Query expects a ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," function to be called with three arguments: ",(0,s.kt)("inlineCode",{parentName:"p"},"args"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"api"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"extraOptions"),". It is expected to return an object with either a ",(0,s.kt)("inlineCode",{parentName:"p"},"data")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"error")," property, or a promise that resolves to return such an object."),(0,s.kt)("h4",{id:"basequery-function-arguments"},"baseQuery function arguments"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="baseQuery example arguments" no-transpile',title:'"baseQuery',example:!0,'arguments"':!0,"no-transpile":!0},"const customBaseQuery = (\n  // highlight-start\n  args,\n  { signal, dispatch, getState },\n  extraOptions\n  // highlight-end\n) => {\n  // omitted\n}\n")),(0,s.kt)("h4",{id:"basequery-function-return-value"},"baseQuery function return value"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected success result format" no-transpile',title:'"Expected',success:!0,result:!0,'format"':!0,"no-transpile":!0},"return { data: YourData }\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected error result format" no-transpile',title:'"Expected',error:!0,result:!0,'format"':!0,"no-transpile":!0},"return { error: YourError }\n")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="baseQuery example return value" no-transpile',title:'"baseQuery',example:!0,return:!0,'value"':!0,"no-transpile":!0},"const customBaseQuery = (\n  args,\n  { signal, dispatch, getState },\n  extraOptions\n) => {\n  // highlight-start\n  if (Math.random() > 0.5) return { error: 'Too high!' }\n  return { data: 'All good!' }\n  // highlight-end\n}\n")),(0,s.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"This format is required so that RTK Query can infer the return types for your responses."))),(0,s.kt)("p",null,"At its core, a ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," function only needs to have the minimum return value to be valid; an object with a ",(0,s.kt)("inlineCode",{parentName:"p"},"data")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"error")," property. It is up to the user to determine how they wish to use the provided arguments, and how requests are handled within the function itself."),(0,s.kt)("h4",{id:"fetchbasequery-defaults"},"fetchBaseQuery defaults"),(0,s.kt)("p",null,"For ",(0,s.kt)("a",{parentName:"p",href:"../api/fetchBaseQuery"},(0,s.kt)("inlineCode",{parentName:"a"},"fetchBaseQuery"))," specifically, the return type is as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Return types of fetchBaseQuery" no-transpile',title:'"Return',types:!0,of:!0,'fetchBaseQuery"':!0,"no-transpile":!0},"Promise<{\n    data: any;\n    error?: undefined;\n    meta?: { request: Request; response: Response };\n} | {\n    error: {\n        status: number;\n        data: any;\n    };\n    data?: undefined;\n    meta?: { request: Request; response: Response };\n}>\n")),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected success result format with fetchBaseQuery" no-transpile',title:'"Expected',success:!0,result:!0,format:!0,with:!0,'fetchBaseQuery"':!0,"no-transpile":!0},"return { data: YourData }\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected error result format with fetchBaseQuery" no-transpile',title:'"Expected',error:!0,result:!0,format:!0,with:!0,'fetchBaseQuery"':!0,"no-transpile":!0},"return { error: { status: number, data: YourErrorData } }\n")))),(0,s.kt)("h2",{id:"customizing-query-responses-with-transformresponse"},"Customizing query responses with ",(0,s.kt)("inlineCode",{parentName:"h2"},"transformResponse")),(0,s.kt)("p",null,"Individual endpoints on ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi"},(0,s.kt)("inlineCode",{parentName:"a"},"createApi"))," accept a ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi"},(0,s.kt)("inlineCode",{parentName:"a"},"transformResponse"))," property which allows manipulation of the data returned by a query or mutation before it hits the cache."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," is called with the data that a successful ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," returns for the corresponding endpoint, and the return value of ",(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," is used as the cached data associated with that endpoint call."),(0,s.kt)("p",null,"By default, the payload from the server is returned directly."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"function defaultTransformResponse(\n  baseQueryReturnValue: unknown,\n  meta: unknown,\n  arg: unknown\n) {\n  return baseQueryReturnValue\n}\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"function defaultTransformResponse(baseQueryReturnValue, meta, arg) {\n  return baseQueryReturnValue\n}\n")))),(0,s.kt)("p",null,"\ubcc0\uacbd\ud558\ub824\uba74 \ub2e4\uc74c\uacfc \uac19\uc740 \ud568\uc218\ub97c \uc81c\uacf5\ud558\uc138\uc694:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Unpack a deeply nested collection" no-transpile',title:'"Unpack',a:!0,deeply:!0,nested:!0,'collection"':!0,"no-transpile":!0},"transformResponse: (response, meta, arg) =>\n  response.some.deeply.nested.collection\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," is called with the ",(0,s.kt)("inlineCode",{parentName:"p"},"meta")," property returned from the ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," as its second\nargument, which can be used while determining the transformed response. The value for ",(0,s.kt)("inlineCode",{parentName:"p"},"meta")," is\ndependent on the ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," used."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="transformResponse meta example" no-transpile',title:'"transformResponse',meta:!0,'example"':!0,"no-transpile":!0},"transformResponse: (response: { sideA: Tracks; sideB: Tracks }, meta, arg) => {\n  if (meta?.coinFlip === 'heads') {\n    return response.sideA\n  }\n  return response.sideB\n}\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," is called with the ",(0,s.kt)("inlineCode",{parentName:"p"},"arg")," property provided to the endpoint as its third\nargument, which can be used while determining the transformed response. The value for ",(0,s.kt)("inlineCode",{parentName:"p"},"arg")," is\ndependent on the ",(0,s.kt)("inlineCode",{parentName:"p"},"endpoint")," used, as well as the argument used when calling the query/mutation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="transformResponse arg example" no-transpile',title:'"transformResponse',arg:!0,'example"':!0,"no-transpile":!0},"transformResponse: (response: Posts, meta, arg) => {\n  return {\n    originalArg: arg,\n    data: response,\n  }\n}\n")),(0,s.kt)("p",null,"While there is less need to store the response in a ",(0,s.kt)("a",{parentName:"p",href:"https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape"},"normalized lookup table")," with RTK Query managing caching data, ",(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," can be leveraged to do so if desired."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Normalize the response data" no-transpile',title:'"Normalize',the:!0,response:!0,'data"':!0,"no-transpile":!0},"transformResponse: (response) =>\n  response.reduce((acc, curr) => {\n    acc[curr.id] = curr\n    return acc\n  }, {})\n\n/*\n  will convert:\n  [\n    {id: 1, name: 'Harry'},\n    {id: 2, name: 'Ron'},\n    {id: 3, name: 'Hermione'},\n  ]\n\n  to:\n  {\n    1: { id: 1, name: \"Harry\" },\n    2: { id: 2, name: \"Ron\" },\n    3: { id: 3, name: \"Hermione\" },\n  }\n*/\n")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createEntityAdapter"},(0,s.kt)("inlineCode",{parentName:"a"},"createEntityAdapter"))," can also be used with ",(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," to normalize data, while also taking advantage of other features provided by ",(0,s.kt)("inlineCode",{parentName:"p"},"createEntityAdapter"),", including providing an ",(0,s.kt)("inlineCode",{parentName:"p"},"ids")," array, using ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createEntityAdapter#sortcomparer"},(0,s.kt)("inlineCode",{parentName:"a"},"sortComparer"))," to maintain a consistently sorted list, as well as maintaining strong TypeScript support."),(0,s.kt)("p",null,"See also ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/streaming-updates#websocket-chat-api-with-a-transformed-response-shape"},"Websocket Chat API with a transformed response shape")," for an example of ",(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," normalizing response data in combination with ",(0,s.kt)("inlineCode",{parentName:"p"},"createEntityAdapter"),", while also updating further data using ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/streaming-updates"},(0,s.kt)("inlineCode",{parentName:"a"},"streaming updates")),"."),(0,s.kt)("h2",{id:"customizing-queries-with-queryfn"},"Customizing queries with ",(0,s.kt)("inlineCode",{parentName:"h2"},"queryFn")),(0,s.kt)("p",null,"Individual endpoints on ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi"},(0,s.kt)("inlineCode",{parentName:"a"},"createApi"))," accept a ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#queryfn"},(0,s.kt)("inlineCode",{parentName:"a"},"queryFn"))," property which allows a given endpoint to ignore ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," for that endpoint by providing an inline function determining how that query resolves."),(0,s.kt)("p",null,"This can be useful for scenarios where you want to have particularly different behaviour for a single endpoint, or where the query itself is not relevant. Such situations may include:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"One-off queries that use a different base URL"),(0,s.kt)("li",{parentName:"ul"},"One-off queries that use different request handling, such as automatic re-tries"),(0,s.kt)("li",{parentName:"ul"},"One-off queries that use different error handling behaviour"),(0,s.kt)("li",{parentName:"ul"},"Performing multiple requests with a single query (",(0,s.kt)("a",{parentName:"li",href:"#performing-multiple-requests-with-a-single-query"},"example"),")"),(0,s.kt)("li",{parentName:"ul"},"Leveraging invalidation behaviour with no relevant query (",(0,s.kt)("a",{parentName:"li",href:"#using-a-no-op-queryfn"},"example"),")"),(0,s.kt)("li",{parentName:"ul"},"Using ",(0,s.kt)("a",{parentName:"li",href:"./streaming-updates"},"Streaming Updates")," with no relevant initial request (",(0,s.kt)("a",{parentName:"li",href:"#streaming-data-with-no-initial-request"},"example"),")")),(0,s.kt)("p",null,"See also ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#queryfn"},(0,s.kt)("inlineCode",{parentName:"a"},"queryFn API Reference"))," for the type signature and available options."),(0,s.kt)("h3",{id:"implementing-a-queryfn"},"Implementing a ",(0,s.kt)("inlineCode",{parentName:"h3"},"queryFn")),(0,s.kt)("p",null,"In order to use ",(0,s.kt)("inlineCode",{parentName:"p"},"queryFn"),", it can be treated as an inline ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery"),". It will be called with the same arguments as ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery"),", as well as the provided ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," function itself (",(0,s.kt)("inlineCode",{parentName:"p"},"arg"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"api"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"extraOptions"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery"),"). Similarly to ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery"),", it is expected to return an object with either a ",(0,s.kt)("inlineCode",{parentName:"p"},"data")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"error")," property, or a promise that resolves to return such an object."),(0,s.kt)("h4",{id:"queryfn-function-arguments"},"queryFn function arguments"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="queryFn example arguments" no-transpile',title:'"queryFn',example:!0,'arguments"':!0,"no-transpile":!0},"const queryFn = (\n  // highlight-start\n  args,\n  { signal, dispatch, getState },\n  extraOptions,\n  baseQuery\n  // highlight-end\n) => {\n  // omitted\n}\n")),(0,s.kt)("h4",{id:"queryfn-function-return-value"},"queryFn function return value"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected success result format" no-transpile',title:'"Expected',success:!0,result:!0,'format"':!0,"no-transpile":!0},"return { data: YourData }\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected error result format" no-transpile',title:'"Expected',error:!0,result:!0,'format"':!0,"no-transpile":!0},"return { error: YourError }\n")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="queryFn example return value" no-transpile',title:'"queryFn',example:!0,return:!0,'value"':!0,"no-transpile":!0},"const queryFn = (\n  args,\n  { signal, dispatch, getState },\n  extraOptions,\n  baseQuery\n) => {\n  // highlight-start\n  if (Math.random() > 0.5) return { error: 'Too high!' }\n  return { data: 'All good!' }\n  // highlight-end\n}\n")),(0,s.kt)("h2",{id:"examples---basequery"},"Examples - ",(0,s.kt)("inlineCode",{parentName:"h2"},"baseQuery")),(0,s.kt)("h3",{id:"axios-basequery"},"Axios baseQuery"),(0,s.kt)("p",null,"This example implements a very basic axios-based ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," utility."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Basic axios baseQuery"',title:'"Basic',axios:!0,'baseQuery"':!0},"import { createApi, BaseQueryFn } from '@reduxjs/toolkit/query'\nimport axios, { AxiosRequestConfig, AxiosError } from 'axios'\n\n// highlight-start\nconst axiosBaseQuery =\n  (\n    { baseUrl }: { baseUrl: string } = { baseUrl: '' }\n  ): BaseQueryFn<\n    {\n      url: string\n      method: AxiosRequestConfig['method']\n      data?: AxiosRequestConfig['data']\n      params?: AxiosRequestConfig['params']\n    },\n    unknown,\n    unknown\n  > =>\n  async ({ url, method, data, params }) => {\n    try {\n      const result = await axios({ url: baseUrl + url, method, data, params })\n      return { data: result.data }\n    } catch (axiosError) {\n      let err = axiosError as AxiosError\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n        },\n      }\n    }\n  }\n// highlight-end\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: axiosBaseQuery({\n    baseUrl: 'https://example.com',\n  }),\n  // highlight-end\n  endpoints(build) {\n    return {\n      query: build.query({ query: () => ({ url: '/query', method: 'get' }) }),\n      mutation: build.mutation({\n        query: () => ({ url: '/mutation', method: 'post' }),\n      }),\n    }\n  },\n})\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Basic axios baseQuery"',title:'"Basic',axios:!0,'baseQuery"':!0},"import { createApi } from '@reduxjs/toolkit/query'\nimport axios from 'axios'\n\n// highlight-start\nconst axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: '' }) =>\n  async ({ url, method, data, params }) => {\n    try {\n      const result = await axios({ url: baseUrl + url, method, data, params })\n      return { data: result.data }\n    } catch (axiosError) {\n      let err = axiosError\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n        },\n      }\n    }\n  }\n// highlight-end\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: axiosBaseQuery({\n    baseUrl: 'https://example.com',\n  }),\n  // highlight-end\n  endpoints(build) {\n    return {\n      query: build.query({ query: () => ({ url: '/query', method: 'get' }) }),\n      mutation: build.mutation({\n        query: () => ({ url: '/mutation', method: 'post' }),\n      }),\n    }\n  },\n})\n")))),(0,s.kt)("h3",{id:"graphql-basequery"},"GraphQL baseQuery"),(0,s.kt)("p",null,"This example implements a very basic GraphQL-based ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery"),"."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Basic GraphQL baseQuery"',title:'"Basic',GraphQL:!0,'baseQuery"':!0},"import { createApi } from '@reduxjs/toolkit/query'\nimport { request, gql, ClientError } from 'graphql-request'\n\n// highlight-start\nconst graphqlBaseQuery =\n  ({ baseUrl }: { baseUrl: string }) =>\n  async ({ body }: { body: string }) => {\n    try {\n      const result = await request(baseUrl, body)\n      return { data: result }\n    } catch (error) {\n      if (error instanceof ClientError) {\n        return { error: { status: error.response.status, data: error } }\n      }\n      return { error: { status: 500, data: error } }\n    }\n  }\n// highlight-end\n\nexport const api = createApi({\n  // highlight-start\n  baseQuery: graphqlBaseQuery({\n    baseUrl: 'https://graphqlzero.almansi.me/api',\n  }),\n  // highlight-end\n  endpoints: (builder) => ({\n    getPosts: builder.query({\n      query: () => ({\n        body: gql`\n          query {\n            posts {\n              data {\n                id\n                title\n              }\n            }\n          }\n        `,\n      }),\n      transformResponse: (response) => response.posts.data,\n    }),\n    getPost: builder.query({\n      query: (id) => ({\n        body: gql`\n        query {\n          post(id: ${id}) {\n            id\n            title\n            body\n          }\n        }\n        `,\n      }),\n      transformResponse: (response) => response.post,\n    }),\n  }),\n})\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Basic GraphQL baseQuery"',title:'"Basic',GraphQL:!0,'baseQuery"':!0},"import { createApi } from '@reduxjs/toolkit/query'\nimport { request, gql, ClientError } from 'graphql-request'\n\n// highlight-start\nconst graphqlBaseQuery =\n  ({ baseUrl }) =>\n  async ({ body }) => {\n    try {\n      const result = await request(baseUrl, body)\n      return { data: result }\n    } catch (error) {\n      if (error instanceof ClientError) {\n        return { error: { status: error.response.status, data: error } }\n      }\n      return { error: { status: 500, data: error } }\n    }\n  }\n// highlight-end\n\nexport const api = createApi({\n  // highlight-start\n  baseQuery: graphqlBaseQuery({\n    baseUrl: 'https://graphqlzero.almansi.me/api',\n  }),\n  // highlight-end\n  endpoints: (builder) => ({\n    getPosts: builder.query({\n      query: () => ({\n        body: gql`\n          query {\n            posts {\n              data {\n                id\n                title\n              }\n            }\n          }\n        `,\n      }),\n      transformResponse: (response) => response.posts.data,\n    }),\n    getPost: builder.query({\n      query: (id) => ({\n        body: gql`\n        query {\n          post(id: ${id}) {\n            id\n            title\n            body\n          }\n        }\n        `,\n      }),\n      transformResponse: (response) => response.post,\n    }),\n  }),\n})\n")))),(0,s.kt)("h3",{id:"automatic-re-authorization-by-extending-fetchbasequery"},"Automatic re-authorization by extending fetchBaseQuery"),(0,s.kt)("p",null,"This example wraps ",(0,s.kt)("a",{parentName:"p",href:"../api/fetchBaseQuery"},(0,s.kt)("inlineCode",{parentName:"a"},"fetchBaseQuery"))," such that when encountering a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401"},(0,s.kt)("inlineCode",{parentName:"a"},"401 Unauthorized"))," error, an additional request is sent to attempt to refresh an authorization token, and re-try to initial query after re-authorizing."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Simulating axios-like interceptors with a custom base query"',title:'"Simulating',"axios-like":!0,interceptors:!0,with:!0,a:!0,custom:!0,base:!0,'query"':!0},"import {\n  BaseQueryFn,\n  FetchArgs,\n  fetchBaseQuery,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\n\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    // try to get a new token\n    const refreshResult = await baseQuery('/refreshToken', api, extraOptions)\n    if (refreshResult.data) {\n      // store the new token\n      api.dispatch(tokenReceived(refreshResult.data))\n      // retry the initial query\n      result = await baseQuery(args, api, extraOptions)\n    } else {\n      api.dispatch(loggedOut())\n    }\n  }\n  return result\n}\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Simulating axios-like interceptors with a custom base query"',title:'"Simulating',"axios-like":!0,interceptors:!0,with:!0,a:!0,custom:!0,base:!0,'query"':!0},"import { fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\n\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    // try to get a new token\n    const refreshResult = await baseQuery('/refreshToken', api, extraOptions)\n    if (refreshResult.data) {\n      // store the new token\n      api.dispatch(tokenReceived(refreshResult.data))\n      // retry the initial query\n      result = await baseQuery(args, api, extraOptions)\n    } else {\n      api.dispatch(loggedOut())\n    }\n  }\n  return result\n}\n")))),(0,s.kt)("h4",{id:"preventing-multiple-unauthorized-errors"},"Preventing multiple unauthorized errors"),(0,s.kt)("p",null,"Using ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/DirtyHairy/async-mutex"},(0,s.kt)("inlineCode",{parentName:"a"},"async-mutex"))," to prevent multiple calls to '/refreshToken' when multiple calls fail with ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401"},(0,s.kt)("inlineCode",{parentName:"a"},"401 Unauthorized"))," errors."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=\"Preventing multiple calls to '/refreshToken'\"",title:'"Preventing',multiple:!0,calls:!0,to:!0,"'/refreshToken'\"":!0},"import {\n  BaseQueryFn,\n  FetchArgs,\n  fetchBaseQuery,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\n// highlight-start\nimport { Mutex } from 'async-mutex'\n// highlight-end\n\n// create a new mutex\n// highlight-start\nconst mutex = new Mutex()\n// highlight-end\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  // wait until the mutex is available without locking it\n  // highlight-start\n  await mutex.waitForUnlock()\n  // highlight-end\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    // checking whether the mutex is locked\n    // highlight-start\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire()\n      // highlight-end\n      try {\n        const refreshResult = await baseQuery(\n          '/refreshToken',\n          api,\n          extraOptions\n        )\n        if (refreshResult.data) {\n          api.dispatch(tokenReceived(refreshResult.data))\n          // retry the initial query\n          result = await baseQuery(args, api, extraOptions)\n        } else {\n          api.dispatch(loggedOut())\n        }\n      } finally {\n        // release must be called once the mutex should be released again.\n        // highlight-start\n        release()\n        // highlight-end\n      }\n    } else {\n      // wait until the mutex is available without locking it\n      // highlight-start\n      await mutex.waitForUnlock()\n      // highlight-end\n      result = await baseQuery(args, api, extraOptions)\n    }\n  }\n  return result\n}\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=\"Preventing multiple calls to '/refreshToken'\"",title:'"Preventing',multiple:!0,calls:!0,to:!0,"'/refreshToken'\"":!0},"import { fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { tokenReceived, loggedOut } from './authSlice'\n// highlight-start\nimport { Mutex } from 'async-mutex'\n// highlight-end\n\n// create a new mutex\n// highlight-start\nconst mutex = new Mutex()\n// highlight-end\nconst baseQuery = fetchBaseQuery({ baseUrl: '/' })\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\n  // wait until the mutex is available without locking it\n  // highlight-start\n  await mutex.waitForUnlock()\n  // highlight-end\n  let result = await baseQuery(args, api, extraOptions)\n  if (result.error && result.error.status === 401) {\n    // checking whether the mutex is locked\n    // highlight-start\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire()\n      // highlight-end\n      try {\n        const refreshResult = await baseQuery(\n          '/refreshToken',\n          api,\n          extraOptions\n        )\n        if (refreshResult.data) {\n          api.dispatch(tokenReceived(refreshResult.data))\n          // retry the initial query\n          result = await baseQuery(args, api, extraOptions)\n        } else {\n          api.dispatch(loggedOut())\n        }\n      } finally {\n        // release must be called once the mutex should be released again.\n        // highlight-start\n        release()\n        // highlight-end\n      }\n    } else {\n      // wait until the mutex is available without locking it\n      // highlight-start\n      await mutex.waitForUnlock()\n      // highlight-end\n      result = await baseQuery(args, api, extraOptions)\n    }\n  }\n  return result\n}\n")))),(0,s.kt)("h3",{id:"automatic-retries"},"Automatic retries"),(0,s.kt)("p",null,"RTK Query exports a utility called ",(0,s.kt)("inlineCode",{parentName:"p"},"retry")," that you can wrap the ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," in your API definition with. It defaults to 5 attempts with a basic exponential backoff."),(0,s.kt)("p",null,"The default behavior would retry at these intervals:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"600ms * random(0.4, 1.4)"),(0,s.kt)("li",{parentName:"ol"},"1200ms * random(0.4, 1.4)"),(0,s.kt)("li",{parentName:"ol"},"2400ms * random(0.4, 1.4)"),(0,s.kt)("li",{parentName:"ol"},"4800ms * random(0.4, 1.4)"),(0,s.kt)("li",{parentName:"ol"},"9600ms * random(0.4, 1.4)")),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",5:!0,className:"language-ts",metastring:'title="Retry every request 5 times by default"',title:'"Retry',every:!0,request:!0,times:!0,by:!0,'default"':!0},"import { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\n// maxRetries: 5 is the default, and can be omitted. Shown for documentation purposes.\nconst staggeredBaseQuery = retry(fetchBaseQuery({ baseUrl: '/' }), {\n  maxRetries: 5,\n})\nexport const api = createApi({\n  baseQuery: staggeredBaseQuery,\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => ({ url: 'posts' }),\n    }),\n    getPost: build.query<PostsResponse, string>({\n      query: (id) => ({ url: `post/${id}` }),\n      extraOptions: { maxRetries: 8 }, // You can override the retry behavior on each endpoint\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery, useGetPostQuery } = api\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",5:!0,className:"language-js",metastring:'title="Retry every request 5 times by default"',title:'"Retry',every:!0,request:!0,times:!0,by:!0,'default"':!0},"import { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react'\n\n// maxRetries: 5 is the default, and can be omitted. Shown for documentation purposes.\nconst staggeredBaseQuery = retry(fetchBaseQuery({ baseUrl: '/' }), {\n  maxRetries: 5,\n})\nexport const api = createApi({\n  baseQuery: staggeredBaseQuery,\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => ({ url: 'posts' }),\n    }),\n    getPost: build.query({\n      query: (id) => ({ url: `post/${id}` }),\n      extraOptions: { maxRetries: 8 }, // You can override the retry behavior on each endpoint\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery, useGetPostQuery } = api\n")))),(0,s.kt)("p",null,"In the event that you didn't want to retry on a specific endpoint, you can just set ",(0,s.kt)("inlineCode",{parentName:"p"},"maxRetries: 0"),"."),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"It is possible for a hook to return ",(0,s.kt)("inlineCode",{parentName:"p"},"data")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"error")," at the same time. By default, RTK Query will keep whatever the last 'good' result was in ",(0,s.kt)("inlineCode",{parentName:"p"},"data")," until it can be updated or garbage collected."))),(0,s.kt)("h4",{id:"bailing-out-of-error-re-tries"},"Bailing out of error re-tries"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"retry")," utility has a ",(0,s.kt)("inlineCode",{parentName:"p"},"fail")," method property attached which can be used to bail out of retries immediately. This can be used for situations where it is known that additional re-tries would be guaranteed to all fail and would be redundant."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Bailing out of error re-tries"',title:'"Bailing',out:!0,of:!0,error:!0,'re-tries"':!0},"import { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react'\nimport { FetchArgs } from '@reduxjs/toolkit/dist/query/fetchBaseQuery'\ninterface Post {\n  id: number\n  name: string\n}\ntype PostsResponse = Post[]\n\n// highlight-start\nconst staggeredBaseQueryWithBailOut = retry(\n  async (args: string | FetchArgs, api, extraOptions) => {\n    const result = await fetchBaseQuery({ baseUrl: '/api/' })(\n      args,\n      api,\n      extraOptions\n    )\n\n    // bail out of re-tries immediately if unauthorized,\n    // because we know successive re-retries would be redundant\n    if (result.error?.status === 401) {\n      retry.fail(result.error)\n    }\n\n    return result\n  },\n  {\n    maxRetries: 5,\n  }\n)\n// highlight-end\n\nexport const api = createApi({\n  // highlight-start\n  baseQuery: staggeredBaseQueryWithBailOut,\n  // highlight-end\n  endpoints: (build) => ({\n    getPosts: build.query<PostsResponse, void>({\n      query: () => ({ url: 'posts' }),\n    }),\n    getPost: build.query<Post, string>({\n      query: (id) => ({ url: `post/${id}` }),\n      extraOptions: { maxRetries: 8 }, // You can override the retry behavior on each endpoint\n    }),\n  }),\n})\nexport const { useGetPostsQuery, useGetPostQuery } = api\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Bailing out of error re-tries"',title:'"Bailing',out:!0,of:!0,error:!0,'re-tries"':!0},"import { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react'\n\n// highlight-start\nconst staggeredBaseQueryWithBailOut = retry(\n  async (args, api, extraOptions) => {\n    const result = await fetchBaseQuery({ baseUrl: '/api/' })(\n      args,\n      api,\n      extraOptions\n    )\n\n    // bail out of re-tries immediately if unauthorized,\n    // because we know successive re-retries would be redundant\n    if (result.error?.status === 401) {\n      retry.fail(result.error)\n    }\n\n    return result\n  },\n  {\n    maxRetries: 5,\n  }\n)\n// highlight-end\n\nexport const api = createApi({\n  // highlight-start\n  baseQuery: staggeredBaseQueryWithBailOut,\n  // highlight-end\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => ({ url: 'posts' }),\n    }),\n    getPost: build.query({\n      query: (id) => ({ url: `post/${id}` }),\n      extraOptions: { maxRetries: 8 }, // You can override the retry behavior on each endpoint\n    }),\n  }),\n})\nexport const { useGetPostsQuery, useGetPostQuery } = api\n")))),(0,s.kt)("h3",{id:"adding-meta-information-to-queries"},"Adding Meta information to queries"),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," can also include a ",(0,s.kt)("inlineCode",{parentName:"p"},"meta")," property in its return value. This can be beneficial in cases where you may wish to include additional information associated with the request such as a request ID or timestamp."),(0,s.kt)("p",null,"In such a scenario, the return value would look like so:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected success result format with meta" no-transpile',title:'"Expected',success:!0,result:!0,format:!0,with:!0,'meta"':!0,"no-transpile":!0},"return { data: YourData, meta: YourMeta }\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Expected error result format with meta" no-transpile',title:'"Expected',error:!0,result:!0,format:!0,with:!0,'meta"':!0,"no-transpile":!0},"return { error: YourError, meta: YourMeta }\n")))),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="baseQuery example with meta information"',title:'"baseQuery',example:!0,with:!0,meta:!0,'information"':!0},"import {\n  BaseQueryFn,\n  FetchArgs,\n  fetchBaseQuery,\n  FetchBaseQueryError,\n  createApi,\n} from '@reduxjs/toolkit/query'\nimport { FetchBaseQueryMeta } from '@reduxjs/toolkit/dist/query/fetchBaseQuery'\nimport { uuid } from './idGenerator'\n\n// highlight-start\ntype Meta = {\n  requestId: string\n  timestamp: number\n}\n// highlight-end\n\n// highlight-start\nconst metaBaseQuery: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError,\n  {},\n  Meta & FetchBaseQueryMeta\n> = async (args, api, extraOptions) => {\n  const requestId = uuid()\n  const timestamp = Date.now()\n\n  const baseResult = await fetchBaseQuery({ baseUrl: '/' })(\n    args,\n    api,\n    extraOptions\n  )\n\n  return {\n    ...baseResult,\n    meta: baseResult.meta && { ...baseResult.meta, requestId, timestamp },\n  }\n}\n// highlight-end\n\nconst DAY_MS = 24 * 60 * 60 * 1000\n\ninterface Post {\n  id: number\n  name: string\n  timestamp: number\n}\ntype PostsResponse = Post[]\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: metaBaseQuery,\n  // highlight-end\n  endpoints: (build) => ({\n    // a theoretical endpoint where we only want to return data\n    // if request was performed past a certain date\n    getRecentPosts: build.query<PostsResponse, void>({\n      query: () => 'posts',\n      // highlight-start\n      transformResponse: (returnValue: PostsResponse, meta) => {\n        // `meta` here contains our added `requestId` & `timestamp`, as well as\n        // `request` & `response` from fetchBaseQuery's meta object.\n        // These properties can be used to transform the response as desired.\n        if (!meta) return []\n        return returnValue.filter(\n          (post) => post.timestamp >= meta.timestamp - DAY_MS\n        )\n      },\n      // highlight-end\n    }),\n  }),\n})\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="baseQuery example with meta information"',title:'"baseQuery',example:!0,with:!0,meta:!0,'information"':!0},"import { fetchBaseQuery, createApi } from '@reduxjs/toolkit/query'\nimport { uuid } from './idGenerator'\n// highlight-end\n\n// highlight-start\nconst metaBaseQuery = async (args, api, extraOptions) => {\n  const requestId = uuid()\n  const timestamp = Date.now()\n\n  const baseResult = await fetchBaseQuery({ baseUrl: '/' })(\n    args,\n    api,\n    extraOptions\n  )\n\n  return {\n    ...baseResult,\n    meta: baseResult.meta && { ...baseResult.meta, requestId, timestamp },\n  }\n}\n// highlight-end\n\nconst DAY_MS = 24 * 60 * 60 * 1000\n\nconst api = createApi({\n  // highlight-start\n  baseQuery: metaBaseQuery,\n  // highlight-end\n  endpoints: (build) => ({\n    // a theoretical endpoint where we only want to return data\n    // if request was performed past a certain date\n    getRecentPosts: build.query({\n      query: () => 'posts',\n      // highlight-start\n      transformResponse: (returnValue, meta) => {\n        // `meta` here contains our added `requestId` & `timestamp`, as well as\n        // `request` & `response` from fetchBaseQuery's meta object.\n        // These properties can be used to transform the response as desired.\n        if (!meta) return []\n        return returnValue.filter(\n          (post) => post.timestamp >= meta.timestamp - DAY_MS\n        )\n      },\n      // highlight-end\n    }),\n  }),\n})\n")))),(0,s.kt)("h3",{id:"constructing-a-dynamic-base-url-using-redux-state"},"Constructing a Dynamic Base URL using Redux state"),(0,s.kt)("p",null,"In some cases, you may wish to have a dynamically altered base url determined from a property in your Redux state. A ",(0,s.kt)("inlineCode",{parentName:"p"},"baseQuery")," has access to a ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#basequery-function-arguments"},(0,s.kt)("inlineCode",{parentName:"a"},"getState"))," method that provides the current store state at the time it is called. This can be used to construct the desired url using a partial url string, and the appropriate data from your store state."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Dynamically generated Base URL example"',title:'"Dynamically',generated:!0,Base:!0,URL:!0,'example"':!0},"import {\n  createApi,\n  BaseQueryFn,\n  FetchArgs,\n  fetchBaseQuery,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query/react'\nimport type { Post } from './types'\nimport { selectProjectId } from './projectSlice'\nimport type { RootState } from '../store'\n\nconst rawBaseQuery = fetchBaseQuery({\n  baseUrl: 'www.my-cool-site.com/',\n})\n\nconst dynamicBaseQuery: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  const projectId = selectProjectId(api.getState() as RootState)\n  // gracefully handle scenarios where data to generate the URL is missing\n  if (!projectId) {\n    return {\n      error: {\n        status: 400,\n        statusText: 'Bad Request',\n        data: 'No project ID received',\n      },\n    }\n  }\n\n  const urlEnd = typeof args === 'string' ? args : args.url\n  // construct a dynamically generated portion of the url\n  const adjustedUrl = `project/${projectId}/${urlEnd}`\n  const adjustedArgs =\n    typeof args === 'string' ? adjustedUrl : { ...args, url: adjustedUrl }\n  // provide the amended url and other params to the raw base query\n  return rawBaseQuery(adjustedArgs, api, extraOptions)\n}\n\nexport const api = createApi({\n  baseQuery: dynamicBaseQuery,\n  endpoints: (builder) => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => 'posts',\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery } = api\n\n/*\n  Using `useGetPostsQuery()` where a `projectId` of 500 is in the redux state will result in\n  a request being sent to www.my-cool-site.com/project/500/posts\n*/\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Dynamically generated Base URL example"',title:'"Dynamically',generated:!0,Base:!0,URL:!0,'example"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { selectProjectId } from './projectSlice'\n\nconst rawBaseQuery = fetchBaseQuery({\n  baseUrl: 'www.my-cool-site.com/',\n})\n\nconst dynamicBaseQuery = async (args, api, extraOptions) => {\n  const projectId = selectProjectId(api.getState())\n  // gracefully handle scenarios where data to generate the URL is missing\n  if (!projectId) {\n    return {\n      error: {\n        status: 400,\n        statusText: 'Bad Request',\n        data: 'No project ID received',\n      },\n    }\n  }\n\n  const urlEnd = typeof args === 'string' ? args : args.url\n  // construct a dynamically generated portion of the url\n  const adjustedUrl = `project/${projectId}/${urlEnd}`\n  const adjustedArgs =\n    typeof args === 'string' ? adjustedUrl : { ...args, url: adjustedUrl }\n  // provide the amended url and other params to the raw base query\n  return rawBaseQuery(adjustedArgs, api, extraOptions)\n}\n\nexport const api = createApi({\n  baseQuery: dynamicBaseQuery,\n  endpoints: (builder) => ({\n    getPosts: builder.query({\n      query: () => 'posts',\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery } = api\n\n/*\n  Using `useGetPostsQuery()` where a `projectId` of 500 is in the redux state will result in\n  a request being sent to www.my-cool-site.com/project/500/posts\n*/\n")))),(0,s.kt)("h2",{id:"examples---transformresponse"},"Examples - ",(0,s.kt)("inlineCode",{parentName:"h2"},"transformResponse")),(0,s.kt)("h3",{id:"unpacking-deeply-nested-graphql-data"},"Unpacking deeply nested GraphQL data"),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="GraphQL transformation example"',title:'"GraphQL',transformation:!0,'example"':!0},"import { createApi } from '@reduxjs/toolkit/query'\nimport { graphqlBaseQuery, gql } from './graphqlBaseQuery'\n\ninterface Post {\n  id: number\n  title: string\n}\n\nexport const api = createApi({\n  baseQuery: graphqlBaseQuery({\n    baseUrl: '/graphql',\n  }),\n  endpoints: (builder) => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => ({\n        body: gql`\n          query {\n            posts {\n              data {\n                id\n                title\n              }\n            }\n          }\n        `,\n      }),\n      // highlight-start\n      transformResponse: (response: { posts: { data: Post[] } }) =>\n        response.posts.data,\n      // highlight-end\n    }),\n  }),\n})\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="GraphQL transformation example"',title:'"GraphQL',transformation:!0,'example"':!0},"import { createApi } from '@reduxjs/toolkit/query'\nimport { graphqlBaseQuery, gql } from './graphqlBaseQuery'\n\nexport const api = createApi({\n  baseQuery: graphqlBaseQuery({\n    baseUrl: '/graphql',\n  }),\n  endpoints: (builder) => ({\n    getPosts: builder.query({\n      query: () => ({\n        body: gql`\n          query {\n            posts {\n              data {\n                id\n                title\n              }\n            }\n          }\n        `,\n      }),\n      // highlight-start\n      transformResponse: (response) => response.posts.data,\n      // highlight-end\n    }),\n  }),\n})\n")))),(0,s.kt)("h3",{id:"normalizing-data-with-createentityadapter"},"Normalizing data with ",(0,s.kt)("inlineCode",{parentName:"h3"},"createEntityAdapter")),(0,s.kt)("p",null,"In the example below, ",(0,s.kt)("inlineCode",{parentName:"p"},"transformResponse")," is used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/api/createEntityAdapter"},(0,s.kt)("inlineCode",{parentName:"a"},"createEntityAdapter"))," to normalize the data before storing it in the cache."),(0,s.kt)("p",null,"For a response such as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"[\n  { id: 1, name: 'Harry' },\n  { id: 2, name: 'Ron' },\n  { id: 3, name: 'Hermione' },\n]\n")),(0,s.kt)("p",null,"The normalized cache data will be stored as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'{\n  ids: [1, 3, 2],\n  entities: {\n    1: { id: 1, name: "Harry" },\n    2: { id: 2, name: "Ron" },\n    3: { id: 3, name: "Hermione" },\n  }\n}\n')),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { createEntityAdapter, EntityState } from '@reduxjs/toolkit'\n\nexport interface Post {\n  id: number\n  name: string\n}\n\n// highlight-start\nconst postsAdapter = createEntityAdapter<Post>({\n  sortComparer: (a, b) => a.name.localeCompare(b.name),\n})\n// highlight-end\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query<EntityState<Post>, void>({\n      query: () => `posts`,\n      // highlight-start\n      transformResponse(response: Post[]) {\n        return postsAdapter.addMany(postsAdapter.getInitialState(), response)\n      },\n      // highlight-end\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery } = api\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport { createEntityAdapter } from '@reduxjs/toolkit'\n\n// highlight-start\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => a.name.localeCompare(b.name),\n})\n// highlight-end\n\nexport const api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => `posts`,\n      // highlight-start\n      transformResponse(response) {\n        return postsAdapter.addMany(postsAdapter.getInitialState(), response)\n      },\n      // highlight-end\n    }),\n  }),\n})\n\nexport const { useGetPostsQuery } = api\n")))),(0,s.kt)("h2",{id:"examples---queryfn"},"Examples - ",(0,s.kt)("inlineCode",{parentName:"h2"},"queryFn")),(0,s.kt)("h3",{id:"using-a-no-op-queryfn"},"Using a no-op queryFn"),(0,s.kt)("p",null,"In certain scenarios, you may wish to have a ",(0,s.kt)("inlineCode",{parentName:"p"},"query")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"mutation")," where sending a request or returning data is not relevant for the situation. Such a scenario would be to leverage the ",(0,s.kt)("inlineCode",{parentName:"p"},"invalidatesTags")," property to force re-fetch specific ",(0,s.kt)("inlineCode",{parentName:"p"},"tags")," that have been provided to the cache."),(0,s.kt)("p",null,"See also ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/automated-refetching#providing-data-to-the-cache"},(0,s.kt)("inlineCode",{parentName:"a"},"providing errors to the cache"))," to see additional detail and an example for such a scenario to 'refetch errored queries'."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Using a no-op queryFn"',title:'"Using',a:!0,"no-op":!0,'queryFn"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query<Post[], void>({\n      query: () => 'posts',\n      providesTags: ['Post'],\n    }),\n\n    getUsers: build.query<User[], void>({\n      query: () => 'users',\n      providesTags: ['User'],\n    }),\n\n    // highlight-start\n    refetchPostsAndUsers: build.mutation<null, void>({\n      // The query is not relevant here, so a `null` returning `queryFn` is used\n      queryFn: () => ({ data: null }),\n      // This mutation takes advantage of tag invalidation behaviour to trigger\n      // any queries that provide the 'Post' or 'User' tags to re-fetch if the queries\n      // are currently subscribed to the cached data\n      invalidatesTags: ['Post', 'User'],\n    }),\n    // highlight-end\n  }),\n})\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Using a no-op queryFn"',title:'"Using',a:!0,"no-op":!0,'queryFn"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Post', 'User'],\n  endpoints: (build) => ({\n    getPosts: build.query({\n      query: () => 'posts',\n      providesTags: ['Post'],\n    }),\n\n    getUsers: build.query({\n      query: () => 'users',\n      providesTags: ['User'],\n    }),\n\n    // highlight-start\n    refetchPostsAndUsers: build.mutation({\n      // The query is not relevant here, so a `null` returning `queryFn` is used\n      queryFn: () => ({ data: null }),\n      // This mutation takes advantage of tag invalidation behaviour to trigger\n      // any queries that provide the 'Post' or 'User' tags to re-fetch if the queries\n      // are currently subscribed to the cached data\n      invalidatesTags: ['Post', 'User'],\n    }),\n    // highlight-end\n  }),\n})\n")))),(0,s.kt)("h3",{id:"streaming-data-with-no-initial-request"},"Streaming data with no initial request"),(0,s.kt)("p",null,"RTK Query provides the ability for an endpoint to send an initial request for data, followed up with recurring ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/usage/streaming-updates"},"streaming updates")," that perform further updates to the cached data as the updates occur. However, the initial request is optional, and you may wish to use streaming updates without any initial request fired off."),(0,s.kt)("p",null,"In the example below, a ",(0,s.kt)("inlineCode",{parentName:"p"},"queryFn")," is used to populate the cache data with an empty array, with no initial request sent. The array is later populated using streaming updates via the ",(0,s.kt)("a",{parentName:"p",href:"/redux-toolkit/rtk-query/api/createApi#oncacheentryadded"},(0,s.kt)("inlineCode",{parentName:"a"},"onCacheEntryAdded"))," endpoint option, updating the cached data as it is received."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Streaming data with no initial request"',title:'"Streaming',data:!0,with:!0,no:!0,initial:!0,'request"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\nimport { Message } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Message'],\n  endpoints: (build) => ({\n    // highlight-start\n    streamMessages: build.query<Message[], void>({\n      // The query is not relevant here as the data will be provided via streaming updates.\n      // A queryFn returning an empty array is used, with contents being populated via\n      // streaming updates below as they are received.\n      queryFn: () => ({ data: [] }),\n      async onCacheEntryAdded(arg, { updateCachedData, cacheEntryRemoved }) {\n        const ws = new WebSocket('ws://localhost:8080')\n        // populate the array with messages as they are received from the websocket\n        ws.addEventListener('message', (event) => {\n          updateCachedData((draft) => {\n            draft.push(JSON.parse(event.data))\n          })\n        })\n        await cacheEntryRemoved\n        ws.close()\n      },\n    }),\n    // highlight-end\n  }),\n})\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Streaming data with no initial request"',title:'"Streaming',data:!0,with:!0,no:!0,initial:!0,'request"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  tagTypes: ['Message'],\n  endpoints: (build) => ({\n    // highlight-start\n    streamMessages: build.query({\n      // The query is not relevant here as the data will be provided via streaming updates.\n      // A queryFn returning an empty array is used, with contents being populated via\n      // streaming updates below as they are received.\n      queryFn: () => ({ data: [] }),\n      async onCacheEntryAdded(arg, { updateCachedData, cacheEntryRemoved }) {\n        const ws = new WebSocket('ws://localhost:8080')\n        // populate the array with messages as they are received from the websocket\n        ws.addEventListener('message', (event) => {\n          updateCachedData((draft) => {\n            draft.push(JSON.parse(event.data))\n          })\n        })\n        await cacheEntryRemoved\n        ws.close()\n      },\n    }),\n    // highlight-end\n  }),\n})\n")))),(0,s.kt)("h3",{id:"performing-multiple-requests-with-a-single-query"},"Performing multiple requests with a single query"),(0,s.kt)("p",null,"In the example below, a query is written to fetch all posts for a random user. This is done using a first request for a random user, followed by getting all posts for that user. Using ",(0,s.kt)("inlineCode",{parentName:"p"},"queryFn")," allows the two requests to be included within a single query, avoiding having to chain that logic within component code."),(0,s.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"ts",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Performing multiple requests with a single query"',title:'"Performing',multiple:!0,requests:!0,with:!0,a:!0,single:!0,'query"':!0},"import {\n  createApi,\n  fetchBaseQuery,\n  FetchBaseQueryError,\n} from '@reduxjs/toolkit/query'\nimport { Post, User } from './types'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/ ' }),\n  endpoints: (build) => ({\n    getRandomUserPosts: build.query<Post, void>({\n      async queryFn(_arg, _queryApi, _extraOptions, fetchWithBQ) {\n        // get a random user\n        const randomResult = await fetchWithBQ('users/random')\n        if (randomResult.error) throw randomResult.error\n        const user = randomResult.data as User\n        const result = await fetchWithBQ(`user/${user.id}/posts`)\n        return result.data\n          ? { data: result.data as Post }\n          : { error: result.error as FetchBaseQueryError }\n      },\n    }),\n  }),\n})\n"))),(0,s.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Performing multiple requests with a single query"',title:'"Performing',multiple:!0,requests:!0,with:!0,a:!0,single:!0,'query"':!0},"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/ ' }),\n  endpoints: (build) => ({\n    getRandomUserPosts: build.query({\n      async queryFn(_arg, _queryApi, _extraOptions, fetchWithBQ) {\n        // get a random user\n        const randomResult = await fetchWithBQ('users/random')\n        if (randomResult.error) throw randomResult.error\n        const user = randomResult.data\n        const result = await fetchWithBQ(`user/${user.id}/posts`)\n        return result.data ? { data: result.data } : { error: result.error }\n      },\n    }),\n  }),\n})\n")))))}c.isMDXComponent=!0}}]);